# main.py

import os
import sys
import json
import argparse
import logging
import traceback
import math
import random
import re
import numpy as np
from pathlib import Path
from collections import defaultdict, Counter

# –ê—É–¥–∏–æ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
from pydub import AudioSegment, effects
import soundfile as sf
import librosa

# –õ–æ–∫–∞–ª—å–Ω—ã–µ –º–æ–¥—É–ª–∏
from config import Config
from smart_mixer import smart_mix
from musicgen_wrapper import generate_music
from self_check import verify_mix

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO, 
    format='[%(levelname)s] %(asctime)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('wavedream.log', encoding='utf-8')
    ]
)

# === –ñ–ê–ù–†–û–í–ê–Ø –î–ï–¢–ï–ö–¶–ò–Ø (–∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —Å—Ç–µ–∫–∞) ===
GENRE_INFO = {
    "trap": {
        "bpm": (130, 150), 
        "core_instruments": ["kick", "snare", "808", "trap_hat"],
        "optional_instruments": ["bell", "lead_synth", "vocal_fx", "clap"],
        "default_tags": ["808", "clap", "trap_hat", "hi-hat", "urban", "drill", "dirty south"],
        "mastering_style": "punchy_aggressive"
    },
    "phonk": {
        "bpm": (85, 115), 
        "core_instruments": ["kick_808", "snare", "phonk_cowbell"],
        "optional_instruments": ["vinyl_fx", "sub", "choir"],
        "default_tags": ["808", "cowbell", "vinyl_fx", "memphis", "slowed"],
        "mastering_style": "vintage_gritty"
    },
    "lofi": {
        "bpm": (60, 80), 
        "core_instruments": ["soft_snare", "rim", "vinyl_fx"],
        "optional_instruments": ["pad", "piano_soft", "hat", "ambience"],
        "default_tags": ["rim", "soft_snare", "vinyl_fx", "lofi", "jazzy", "chillhop"],
        "mastering_style": "warm_cozy"
    },
    "ambient": {
        "bpm": (60, 75), 
        "core_instruments": ["pad", "drone", "texture"],
        "optional_instruments": ["bell", "piano", "fx", "ambience"],
        "default_tags": ["pad", "bell", "reverb_fx", "space", "drone", "meditation"],
        "mastering_style": "spacious_ethereal"
    },
    "edm": {
        "bpm": (120, 128), 
        "core_instruments": ["kick", "snare", "clap"],
        "optional_instruments": ["lead_synth", "riser", "pad", "arp", "bass"],
        "default_tags": ["kick", "clap", "lead_synth", "riser", "festival"],
        "mastering_style": "loud_festival"
    },
    "dnb": {
        "bpm": (170, 180), 
        "core_instruments": ["snare_dnb", "break", "reese_bass"],
        "optional_instruments": ["hat", "fx", "pad"],
        "default_tags": ["break", "reese_bass", "pad", "neurofunk", "industrial"],
        "mastering_style": "tight_punchy"
    },
    "techno": {
        "bpm": (125, 135), 
        "core_instruments": ["kick_techno", "hat", "tech_bass"],
        "optional_instruments": ["ride", "stab", "modular", "fx"],
        "default_tags": ["kick_techno", "hat", "ride", "tech_bass", "modular"],
        "mastering_style": "industrial_clean"
    },
    "house": {
        "bpm": (118, 125), 
        "core_instruments": ["kick", "clap", "hat"],
        "optional_instruments": ["house_loop", "groove", "bass", "pluck"],
        "default_tags": ["clap", "hat", "house_loop", "groove", "bass"],
        "mastering_style": "groovy_warm"
    },
    "cinematic": {
        "bpm": (60, 100), 
        "core_instruments": ["braam", "string_ensemble", "drone"],
        "optional_instruments": ["choir", "impact", "timpani", "texture"],
        "default_tags": ["braam", "string_ensemble", "choir", "impact"],
        "mastering_style": "epic_cinematic"
    },
    "hyperpop": {
        "bpm": (140, 180), 
        "core_instruments": ["glitchcore", "vocal_fx", "distorted"],
        "optional_instruments": ["overprocessed", "808", "lead_synth"],
        "default_tags": ["glitchcore", "overprocessed", "vocal_fx", "distorted"],
        "mastering_style": "hyper_saturated"
    }
}

GENRE_KEYWORDS = {
    "trap": [
        "trap", "dark trap", "drill", "cloud trap", "memphis", "southern trap", "trap metal", "emo trap",
        "rage trap", "russian trap", "pluggnb", "hypertrap", "–≥—Ä—è–∑–Ω—ã–π", "—É–ª–∏—á–Ω—ã–π", "–¥–µ—Ä–∑–∫–∏–π", "–∑–ª–æ–π", 
        "–∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π", "—É–≥—Ä–æ–∂–∞—é—â–∏–π", "–∂—ë—Å—Ç–∫–∏–π", "–º—Ä–∞—á–Ω—ã–π", "–±–∞–Ω–¥–∞", "—Å—Ç—Ä–µ–ª–∫–∞", "–≤–æ—Ä–æ–Ω–∫–∞", "–≥–∞–Ω–≥—Å—Ç–∞", "–≥–µ—Ç—Ç–æ"
    ],
    "phonk": [
        "phonk", "—Ñ–∞–Ω–∫", "memphis rap", "cowbell phonk", "drift phonk", "underground phonk",
        "–æ–ª–¥—Å–∫—É–ª", "–≥—Ä—è–∑–Ω—ã–π", "–ª–æ—É—Ñ–∞–π", "—É–ª–∏—á–Ω—ã–π —Å—Ç–∏–ª—å", "—Ä–µ—Ç—Ä–æ –≤–∞–π–±", "–Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ", "—Ä–∞–∑–≥–æ–Ω", "–∞–≥—Ä–µ—Å—Å–∏—è"
    ],
    "lofi": [
        "lofi", "lo-fi", "–ª–æ—É—Ñ–∞–π", "–ª–æ—É —Ñ–∞–π", "—á–∏–ª–∞—É—Ç", "chillhop", "jazzhop", "sleep beats", "study beats", 
        "–∏–Ω–¥–∏ —Ö–∏–ø-—Ö–æ–ø", "lazy beats", "dreamhop", "slowhop", "—É—é—Ç", "—Ç–µ–ø–ª–æ", "–∫—Ä—É–∂–∫–∞ —á–∞—è", "–æ–∫–Ω–æ", "–¥–æ–∂–¥—å", 
        "–Ω–æ—á–Ω–æ–π –≥–æ—Ä–æ–¥", "—Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–∏–µ", "–ª–∞–º–ø–∞", "–≤–µ—á–µ—Ä", "–ø–æ–¥ –æ–¥–µ—è–ª–æ–º", "—à–æ—Ä–æ—Ö–∏", "–ø–æ—Ç—Ä–µ—Å–∫–∏–≤–∞–Ω–∏–µ", "–º—è–≥–∫–∏–π", 
        "—Å–ø–æ–∫–æ–π—Å—Ç–≤–∏–µ", "–º–µ–ª–∞–Ω—Ö–æ–ª–∏—è"
    ],
    "dnb": [
        "dnb", "drum and bass", "–¥—Ä–∞–º", "–¥—Ä–∞–º-–Ω-–±—ç–π—Å", "neurofunk", "liquid funk", "techstep",
        "jump up", "rollers", "atmospheric dnb", "intelligent dnb", "jungle", "–¥–∂–∞–Ω–≥–ª", "darkstep",
        "halftime", "hard dnb", "rough", "raw", "neuro", "—Ä–∞–∑–≥–æ–Ω", "–¥–∏–Ω–∞–º–∏–∫–∞", "—Ç–µ–Ω—à–Ω"
    ],
    "ambient": [
        "ambient", "—ç–º–±–∏–µ–Ω—Ç", "—Å–∞—É–Ω–¥—Å–∫–µ–π–ø", "drone", "meditation music", "space ambient", "textural ambient",
        "deep ambient", "slow wave", "soundscape", "nature ambient", "dark ambient", "liquid ambient",
        "—Ç–∏—à–∏–Ω–∞", "–æ–∫–µ–∞–Ω", "–≤–æ–¥–∞", "–º–æ—Ä–µ", "–∫–æ—Å–º–æ—Å", "–∑–≤—ë–∑–¥—ã", "–≤—Ä–µ–º—è", "–≤–µ—á–Ω–æ—Å—Ç—å", "–ø–æ–∫–æ–π", 
        "–º–µ–¥–∏—Ç–∞—Ü–∏—è", "–±–µ–∑–º—è—Ç–µ–∂–Ω–æ—Å—Ç—å", "–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ", "–Ω–∏—á—Ç–æ", "–ø–ª–∞–≤–Ω–æ—Å—Ç—å", "—Å–æ–Ω", "–æ—Ç—Ä–∞–∂–µ–Ω–∏–µ"
    ],
    "techno": [
        "techno", "—Ç–µ—Ö–Ω–æ", "acid", "industrial techno", "minimal techno", "hard techno", "raw", 
        "warehouse", "detroit techno", "hypnotic", "berghain", "underground", "–ø–ª–æ—Ç–Ω–æ", "—Ü–∏—Ñ—Ä–æ–≤–æ–π", 
        "—Ç–µ—Ö–Ω–∏—á–Ω—ã–π", "—Ä–æ–±–æ—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π", "–º–µ—Ö–∞–Ω–∏–∫–∞", "—Å—Ç—Ä–æ–≥–∏–π", "—Å—É—Ö–æ–π", "–º–∞—Å—Å–∏–≤–Ω—ã–π", "–±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ä–∏—Ç–º"
    ],
    "house": [
        "house", "deep house", "tech house", "progressive house", "chicago house", "french house",
        "groove", "–∫–∞—á", "–≤–µ—á–µ—Ä–∏–Ω–∫–∞", "–∫–ª—É–±", "–ø–ª—è–∂", "–¥–∏—Å–∫–æ—Ç–µ–∫–∞", "—Ç–∞–Ω–µ—Ü", "—ç–Ω–µ—Ä–≥–∏—è", 
        "–¥—Ä–∞–π–≤", "hypnotic rhythm", "–∫–∞—á–∞–µ—Ç", "—Ñ–∞–Ω–∫", "—Å–æ—É–ª –≤–∞–π–±"
    ],
    "cinematic": [
        "cinematic", "—Å–∞—É–Ω–¥—Ç—Ä–µ–∫", "score", "film score", "epic", "orchestral", "trailer music", 
        "soundtrack", "drama score", "ambient score", "hybrid score", "fantasy music", "sci-fi music",
        "–±–∏—Ç–≤–∞", "–≥–µ—Ä–æ–∏–∑–º", "–≤–¥–æ—Ö–Ω–æ–≤–µ–Ω–∏–µ", "–ø–µ—á–∞–ª—å", "–æ–ø–∞—Å–Ω–æ—Å—Ç—å", "–ø–æ–≤–æ—Ä–æ—Ç —Å—é–∂–µ—Ç–∞", "—Ä–∞–∑–≤—è–∑–∫–∞", 
        "–Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ", "–º–≥–Ω–æ–≤–µ–Ω–∏–µ", "–∫–∞—Ç–∞—Ä—Å–∏—Å", "–≤–µ–ª–∏—á–∏–µ", "—Ç—Ä–∞–≥–∏–∑–º", "–º–∏—Å—Ç–∏–∫–∞", "–≥–ª—É–±–∏–Ω–∞"
    ],
    "edm": [
        "edm", "electronic dance music", "festival", "big room", "progressive", "electro house",
        "—ç–Ω–µ—Ä–≥–∏—è", "—Ñ–µ—Å—Ç–∏–≤–∞–ª—å", "—Ç–∞–Ω—Ü–ø–æ–ª", "–¥—Ä–∞–π–≤", "–º–∞—Å—Å–æ–≤–æ—Å—Ç—å", "—ç–π—Ñ–æ—Ä–∏—è", "–ø–æ–¥—ä—ë–º"
    ],
    "hyperpop": [
        "hyperpop", "glitchcore", "digicore", "breakcore", "speedcore", "pc music",
        "–≥–∏–ø–µ—Ä–ø–æ–ø", "–≥–ª–∏—Ç—á–∫–æ—Ä", "–¥–∏—Å—Ç–æ—Ä—à–Ω", "–ø–µ—Ä–µ–≥—Ä—É–∑", "—Ö–∞–æ—Ç–∏—á–Ω–æ", "–∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ", "—ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω–æ"
    ]
}

def detect_genre(prompt: str):
    """–î–µ—Ç–µ–∫—Ü–∏—è –∂–∞–Ω—Ä–∞ –∏–∑ –ø—Ä–æ–º–ø—Ç–∞"""
    prompt_lower = prompt.lower()
    
    # 1. –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞
    for genre in GENRE_INFO.keys():
        if genre in prompt_lower:
            logging.info(f"üé≠ –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞: {genre}")
            return genre, GENRE_INFO[genre]
    
    # 2. –°–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
    genre_scores = {}
    for genre, keywords in GENRE_KEYWORDS.items():
        score = sum(1 for keyword in keywords if keyword in prompt_lower)
        if score > 0:
            genre_scores[genre] = score
    
    if genre_scores:
        best_genre = max(genre_scores, key=genre_scores.get)
        logging.info(f"üéØ –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∞–Ω—Ä: {best_genre} (score: {genre_scores[best_genre]})")
        return best_genre, GENRE_INFO[best_genre]
    
    # 3. –ü–æ–ø—ã—Ç–∫–∞ –ø–æ BPM
    bpm_match = re.findall(r'\b(\d{2,3})\s*bpm\b', prompt_lower)
    if bpm_match:
        target_bpm = int(bpm_match[0])
        best_genre = None
        min_diff = float('inf')
        
        for genre, info in GENRE_INFO.items():
            bpm_range = info["bpm"]
            avg_bpm = (bpm_range[0] + bpm_range[1]) / 2
            diff = abs(avg_bpm - target_bpm)
            if diff < min_diff:
                min_diff = diff
                best_genre = genre
        
        if best_genre:
            logging.info(f"üéµ –ñ–∞–Ω—Ä –ø–æ BPM {target_bpm}: {best_genre}")
            return best_genre, GENRE_INFO[best_genre]
    
    # 4. –§–æ–ª–±—ç–∫
    logging.warning("‚ö†Ô∏è –ñ–∞–Ω—Ä –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è trap –∫–∞–∫ –¥–µ—Ñ–æ–ª—Ç")
    return "trap", GENRE_INFO["trap"]

# === –†–ê–°–®–ò–†–ï–ù–ù–´–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–ê–õ–¨–ù–´–ï –¢–ï–ì–ò ===
INSTRUMENT_TO_TAGS = {
    "kick": ["kick", "hard_kick", "low_drum", "bd", "bass_drum"],
    "snare": ["snare", "tight_snare", "snappy", "snr"],
    "trap_hat": ["trap_hat", "rolling_hat", "rapid_hat", "hat", "hi_hat"],
    "808": ["808", "sub_bass", "deep", "sub"],
    "clap": ["clap", "sharp_clap"],
    "bell": ["bell", "chime", "glockenspiel", "trap_bell", "dark_bell"],
    "lead_synth": ["lead", "synth", "melody", "lead_synth"],
    "vocal_fx": ["vocal_fx", "processed_vocal", "vox", "vocal"],
    "piano": ["piano", "keys", "soft_piano", "felt_piano"],
    "pad": ["pad", "ambient", "texture", "analog_pad", "warm_pad"],
    "fx": ["fx", "effect", "noise", "sweep", "impact", "reverse"],
    "bass": ["bass", "electric_bass", "low", "bassline"],
    "phonk_cowbell": ["cowbell", "phonk_cowbell", "memphis"],
    "vinyl_fx": ["vinyl", "lofi_texture", "crackle", "vinyl_fx"],
    "drone": ["drone", "low", "ambience", "ambient_drone"],
    "texture": ["texture", "grain", "soundscape", "background"],
    "braam": ["braam", "low_hit", "epic", "cinematic_hit"],
    "string_ensemble": ["string_ensemble", "orchestra", "strings", "violin", "cello"],
    "choir": ["choir", "choral", "voices", "male_choir", "female_choir"],
    "reese_bass": ["reese", "bass", "neuro", "reese_bass"],
    "break": ["break", "drum_break", "amen", "breakbeat"],
    "snare_dnb": ["dnb_snare", "crack_snare", "fast_snare", "snare_dnb"],
    "kick_techno": ["techno_kick", "punchy_kick", "deep_kick", "kick_techno"],
    "tech_bass": ["tech_bass", "rolling_bass", "techno_bass"],
    "modular": ["modular", "modular_synth", "analog", "eurorack"],
    "house_loop": ["house_loop", "groove_loop", "percussive_loop"],
    "pluck": ["pluck", "synth_pluck", "short", "house_pluck"]
}

def expand_instrument_tags(instrument):
    """–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ç–µ–≥–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""
    return INSTRUMENT_TO_TAGS.get(instrument, [instrument])

class EnhancedSamplePicker:
    """–£–ª—É—á—à–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–æ–¥–±–æ—Ä–∞ —Å—ç–º–ø–ª–æ–≤ —Å —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–º –∞–Ω–∞–ª–∏–∑–æ–º –∏ –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–µ–π"""
    
    def __init__(self, sample_dir, index_file="enhanced_sample_index.json"):
        self.sample_dir = sample_dir
        self.index_file = os.path.join(sample_dir, index_file)
        self.config = Config()
        
        # –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –∫–∞—Ä—Ç–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è
        self.semantic_map = {**self.config.SEMANTIC_MAP, **INSTRUMENT_TO_TAGS}
        self.genre_settings = GENRE_INFO
        
        self.index = self.load_or_build_index()
    
    def analyze_filename_advanced(self, filename):
        """–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –∞–Ω–∞–ª–∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π"""
        name = filename.lower()
        tags = set()
        bpm = 120
        key = None
        
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ BPM
        bpm_patterns = [r'(\d{2,3})bpm', r'(\d{2,3})_bpm', r'bpm(\d{2,3})', r'(\d{2,3})bp']
        for pattern in bpm_patterns:
            match = re.search(pattern, name)
            if match:
                bpm = int(match.group(1))
                break
        
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
        key_patterns = [r'([A-G][#b]?)_?maj', r'([A-G][#b]?)_?min', r'key_([A-G][#b]?)', r'([A-G][#b]?)_key']
        for pattern in key_patterns:
            match = re.search(pattern, name)
            if match:
                key = match.group(1).upper()
                break
        
        # –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —á–µ—Ä–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é –∫–∞—Ä—Ç—É
        for instrument, synonyms in self.semantic_map.items():
            if isinstance(synonyms, list):
                for synonym in synonyms:
                    if synonym in name:
                        tags.add(instrument)
                        break
            elif isinstance(synonyms, dict):
                for synonym in synonyms.get("synonyms", []):
                    if synonym in name:
                        tags.add(instrument)
                        tags.update(synonyms.get("related", []))
                        break
        
        # –ñ–∞–Ω—Ä–æ–≤—ã–µ —Ç–µ–≥–∏ –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
        for genre, keywords in GENRE_KEYWORDS.items():
            for keyword in keywords[:5]:  # –ë–µ—Ä—ë–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 5 –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤
                if keyword in name:
                    tags.add(f"genre_{genre}")
                    break
        
        return list(tags), bpm, key
    
    def analyze_audio_content(self, file_path, max_duration=10):
        """–ê–Ω–∞–ª–∏–∑ –∞—É–¥–∏–æ–∫–æ–Ω—Ç–µ–Ω—Ç–∞ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –¥–µ—Ç–µ–∫—Ü–∏–µ–π"""
        try:
            y, sr = librosa.load(file_path, duration=max_duration, sr=22050)
            
            # –ê–Ω–∞–ª–∏–∑ —Ç–µ–º–ø–∞
            tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
            tempo = float(tempo)
            
            # –ê–Ω–∞–ª–∏–∑ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
            chroma = librosa.feature.chroma_cqt(y=y, sr=sr)
            if chroma.size > 0:
                chroma_mean = chroma.mean(axis=1)
                key_idx = chroma_mean.argmax()
                keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
                key = keys[key_idx]
            else:
                key = None
            
            # –°–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
            spectral_centroid = librosa.feature.spectral_centroid(y=y, sr=sr).mean()
            spectral_rolloff = librosa.feature.spectral_rolloff(y=y, sr=sr).mean()
            zero_crossing_rate = librosa.feature.zero_crossing_rate(y).mean()
            mfcc = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
            content_tags = []
            
            # –ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ —á–∞—Å—Ç–æ—Ç–Ω–æ–º—É —Å–ø–µ–∫—Ç—Ä—É
            if spectral_centroid < 800:
                content_tags.extend(["bass", "kick", "sub", "808"])
            elif spectral_centroid < 2000:
                content_tags.extend(["snare", "mid_freq", "vocal"])
            elif spectral_centroid < 8000:
                content_tags.extend(["lead", "melody", "synth"])
            else:
                content_tags.extend(["hihat", "cymbal", "fx", "bright"])
            
            # –†–∏—Ç–º–∏—á–µ—Å–∫–∏–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
            if zero_crossing_rate > 0.15:
                content_tags.extend(["percussion", "rhythmic", "transient"])
            elif zero_crossing_rate < 0.05:
                content_tags.extend(["sustained", "pad", "drone"])
            
            # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ loop vs oneshot
            duration_sec = len(y) / sr
            if duration_sec > 8:
                content_tags.append("loop")
            else:
                content_tags.append("oneshot")
            
            # MFCC-–∞–Ω–∞–ª–∏–∑ –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏
            mfcc_mean = mfcc.mean(axis=1)
            if mfcc_mean[1] > 50:  # –ü–µ—Ä–≤—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –ø–æ—Å–ª–µ —ç–Ω–µ—Ä–≥–∏–∏
                content_tags.append("bright_timbre")
            elif mfcc_mean[1] < -50:
                content_tags.append("dark_timbre")
            
            return {
                "tempo": max(60, min(200, tempo)),
                "key": key,
                "content_tags": content_tags,
                "spectral_centroid": float(spectral_centroid),
                "brightness": float(spectral_rolloff / sr),
                "rhythmic_complexity": float(zero_crossing_rate),
                "duration": duration_sec
            }
        except Exception as e:
            logging.warning(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {file_path}: {e}")
            return {"tempo": 120, "key": None, "content_tags": [], "spectral_centroid": 0, "brightness": 0, "rhythmic_complexity": 0, "duration": 0}
    
    def build_enhanced_index(self):
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ —Å—ç–º–ø–ª–æ–≤ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π"""
        logging.info("üîç –ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—é —Å—ç–º–ø–ª–æ–≤...")
        enhanced_index = []
        processed = 0
        
        for root, _, files in os.walk(self.sample_dir):
            for file in files:
                if file.lower().endswith(('.wav', '.mp3', '.aiff', '.flac')):
                    full_path = os.path.join(root, file)
                    try:
                        # –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                        audio = AudioSegment.from_file(full_path)
                        duration = len(audio) / 1000
                        
                        # –ê–Ω–∞–ª–∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
                        filename_tags, filename_bpm, filename_key = self.analyze_filename_advanced(file)
                        
                        # –ê–Ω–∞–ª–∏–∑ –∞—É–¥–∏–æ–∫–æ–Ω—Ç–µ–Ω—Ç–∞
                        audio_analysis = self.analyze_audio_content(full_path)
                        
                        # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
                        final_bpm = filename_bpm if filename_bpm != 120 else audio_analysis["tempo"]
                        final_key = filename_key or audio_analysis["key"]
                        all_tags = list(set(filename_tags + audio_analysis["content_tags"]))
                        
                        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
                        category = "loop" if duration > 8 else "oneshot"
                        if "loop" in filename_tags or "loop" in file.lower():
                            category = "loop"
                        
                        # –ñ–∞–Ω—Ä–æ–≤–∞—è –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ –ø—É—Ç–∏
                        path_lower = full_path.lower()
                        detected_genres = []
                        for genre, keywords in GENRE_KEYWORDS.items():
                            for keyword in keywords[:3]:  # –¢–æ–ø-3 –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤–∞
                                if keyword in path_lower:
                                    detected_genres.append(genre)
                                    break
                        
                        entry = {
                            "path": full_path,
                            "filename": file,
                            "tempo": round(final_bpm),
                            "duration": round(duration, 3),
                            "key": final_key,
                            "category": category,
                            "tags": all_tags,
                            "genres": detected_genres,
                            "spectral_centroid": audio_analysis["spectral_centroid"],
                            "brightness": audio_analysis["brightness"],
                            "rhythmic_complexity": audio_analysis.get("rhythmic_complexity", 0),
                            "relative_path": os.path.relpath(full_path, self.sample_dir)
                        }
                        
                        enhanced_index.append(entry)
                        processed += 1
                        
                        if processed % 50 == 0:
                            logging.info(f"‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {processed} —Ñ–∞–π–ª–æ–≤")
                    
                    except Exception as e:
                        logging.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ {file}: {e}")
        
        logging.info(f"üéØ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –∏–Ω–¥–µ–∫—Å–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞: {len(enhanced_index)} —Å—ç–º–ø–ª–æ–≤")
        return enhanced_index
    
    def load_or_build_index(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞"""
        if os.path.exists(self.index_file):
            try:
                with open(self.index_file, 'r', encoding='utf-8') as f:
                    index = json.load(f)
                logging.info(f"üìö –ó–∞–≥—Ä—É–∂–µ–Ω —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å: {len(index)} —Å—ç–º–ø–ª–æ–≤")
                return index
            except Exception as e:
                logging.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–Ω–¥–µ–∫—Å–∞: {e}")
        
        # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å
        index = self.build_enhanced_index()
        self.save_index(index)
        return index
    
    def save_index(self, index):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞"""
        with open(self.index_file, 'w', encoding='utf-8') as f:
            json.dump(index, f, indent=2, ensure_ascii=False)
        logging.info(f"üíæ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {self.index_file}")
    
    def score_sample_with_genre(self, sample, query_tags, target_tempo=120, genre_hint=None, mood_hint=None):
        """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å–∫–æ—Ä–∏–Ω–≥–∞ —Å —É—á—ë—Ç–æ–º –∂–∞–Ω—Ä–∞ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è"""
        score = 0
        sample_tags = sample.get("tags", [])
        sample_tempo = sample.get("tempo", 120)
        sample_genres = sample.get("genres", [])
        
        # 1. –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π —Å–∫–æ—Ä–∏–Ω–≥ —Ç–µ–≥–æ–≤ (50% –≤–µ—Å–∞)
        tag_score = 0
        for query_tag in query_tags:
            # –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
            if query_tag in sample_tags:
                tag_score += 10
            else:
                # –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                expanded_tags = expand_instrument_tags(query_tag)
                for expanded in expanded_tags:
                    for sample_tag in sample_tags:
                        if expanded in sample_tag or sample_tag in expanded:
                            tag_score += 5
                        elif self.fuzzy_match(expanded, sample_tag):
                            tag_score += 3
        
        if query_tags:
            tag_score = tag_score / len(query_tags)
        score += tag_score * 0.5
        
        # 2. –ñ–∞–Ω—Ä–æ–≤–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å (25% –≤–µ—Å–∞)
        genre_score = 0
        if genre_hint:
            if genre_hint in sample_genres:
                genre_score = 25
            elif any(genre_hint[:4] in g for g in sample_genres):
                genre_score = 15
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ –ø—É—Ç–∏ —Ñ–∞–π–ª–∞
            sample_path = sample.get("path", "").lower()
            if genre_hint in sample_path:
                genre_score += 10
        
        score += genre_score * 0.25
        
        # 3. –¢–µ–º–ø–æ–≤–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å (15% –≤–µ—Å–∞)
        tempo_diff = abs(sample_tempo - target_tempo)
        if tempo_diff <= 3:
            tempo_score = 20
        elif tempo_diff <= 10:
            tempo_score = 15 - (tempo_diff / 10) * 10
        elif tempo_diff <= 20:
            tempo_score = 5
        else:
            tempo_score = 1
        
        score += tempo_score * 0.15
        
        # 4. –ö–∞—á–µ—Å—Ç–≤–æ –∏ —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ (10% –≤–µ—Å–∞)
        quality_score = 0
        if len(sample_tags) > 2:
            quality_score += 5
        if sample.get("key"):
            quality_score += 3
        if 1 < sample.get("duration", 0) < 60:
            quality_score += 5
        if sample.get("brightness", 0) > 0:
            quality_score += 2
        
        score += quality_score * 0.1
        
        return score
    
    def fuzzy_match(self, a, b, threshold=0.6):
        """–£–ª—É—á—à–µ–Ω–Ω–æ–µ –Ω–µ—á—ë—Ç–∫–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ"""
        a, b = a.lower(), b.lower()
        if a == b:
            return True
        if a in b or b in a:
            return True
        
        # Jaccard similarity
        set_a, set_b = set(a), set(b)
        intersection = len(set_a & set_b)
        union = len(set_a | set_b)
        return (intersection / union) > threshold if union > 0 else False
    
    def pick_samples_for_genre_structure(self, section, target_tempo, genre_hint=None, mood_hint=None, top_k=3):
        """–ü–æ–¥–±–æ—Ä —Å—ç–º–ø–ª–æ–≤ –¥–ª—è —Å–µ–∫—Ü–∏–∏ —Å —É—á—ë—Ç–æ–º –∂–∞–Ω—Ä–∞"""
        section_type = section.get("type", "unknown")
        required_instruments = []
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è —Å–µ–∫—Ü–∏–∏ –ø–æ –∂–∞–Ω—Ä—É
        if genre_hint in self.genre_settings:
            genre_config = self.genre_settings[genre_hint]
            core_instruments = genre_config.get("core_instruments", [])
            optional_instruments = genre_config.get("optional_instruments", [])
            
            # –ë–∞–∑–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –≤—Å–µ—Ö —Å–µ–∫—Ü–∏–π
            required_instruments.extend(core_instruments)
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Å–µ–∫—Ü–∏–∏
            if section_type in ["hook", "drop", "climax", "peak", "chorus"]:
                required_instruments.extend(optional_instruments)
            elif section_type in ["verse", "build", "development"]:
                required_instruments.extend(optional_instruments[:2])
        else:
            # –î–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
            required_instruments = ["kick", "bass", "lead"]
        
        # –ü–æ–¥–±–∏—Ä–∞–µ–º —Å—ç–º–ø–ª—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
        section_samples = []
        for instrument in required_instruments:
            instrument_tags = expand_instrument_tags(instrument)
            
            instrument_samples = self.pick_samples_enhanced(
                required_tags=instrument_tags,
                target_tempo=target_tempo,
                genre_hint=genre_hint,
                mood_hint=mood_hint,
                top_k=1,
                min_score=3
            )
            
            if instrument_samples:
                best_sample = instrument_samples[0]
                best_sample["instrument_role"] = instrument
                section_samples.append(best_sample)
                logging.info(f"‚úÖ [{section_type}] {instrument}: {best_sample['filename']}")
            else:
                logging.warning(f"‚ö†Ô∏è [{section_type}] –ù–µ –Ω–∞–π–¥–µ–Ω —Å—ç–º–ø–ª –¥–ª—è {instrument}")
        
        return section_samples
    
    def pick_samples_enhanced(self, required_tags, target_tempo=120, genre_hint=None, mood_hint=None, top_k=10, min_score=5):
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–æ–¥–±–æ—Ä —Å—ç–º–ø–ª–æ–≤ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π"""
        if not self.index:
            logging.error("‚ùå –ò–Ω–¥–µ–∫—Å –ø—É—Å—Ç!")
            return []
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –ø–æ–∏—Å–∫ —Å –∂–∞–Ω—Ä–æ–≤—ã–º —Å–∫–æ—Ä–∏–Ω–≥–æ–º
        matches = []
        for sample in self.index:
            score = self.score_sample_with_genre(
                sample, required_tags, target_tempo, genre_hint, mood_hint
            )
            if score >= min_score:
                matches.append((score, sample))
        
        # –ï—Å–ª–∏ –º–∞–ª–æ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–π - —Å–º—è–≥—á–∞–µ–º –∫—Ä–∏—Ç–µ—Ä–∏–∏
        if len(matches) < top_k:
            for sample in self.index:
                if any((score, sample) in matches for score, _ in matches):
                    continue
                score = self.score_sample_with_genre(
                    sample, required_tags, target_tempo, genre_hint, mood_hint
                )
                if score >= min_score * 0.5:
                    matches.append((score, sample))
        
        # –§–æ–ª–±–µ–∫ –ø–æ –∂–∞–Ω—Ä—É –∏ —Ç–µ–º–ø—É
        if len(matches) < 3 and genre_hint:
            for sample in self.index:
                sample_path = sample.get("path", "").lower()
                sample_tempo = sample.get("tempo", 120)
                sample_genres = sample.get("genres", [])
                
                genre_match = genre_hint in sample_genres or genre_hint in sample_path
                tempo_match = abs(sample_tempo - target_tempo) <= 30
                
                if genre_match or tempo_match:
                    fallback_score = 3 + (10 if genre_match else 0) + (3 if tempo_match else 0)
                    matches.append((fallback_score, sample))
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏ –≤–æ–∑–≤—Ä–∞—Ç
        matches.sort(key=lambda x: -x[0])
        return [sample for _, sample in matches[:top_k]]


def query_structured_music(prompt):
    """–ó–∞–ø—Ä–æ—Å –∫ LLaMA3 –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ç—Ä–µ–∫–∞ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–µ–π"""
    try:
        import subprocess
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∂–∞–Ω—Ä –∏–∑ –ø—Ä–æ–º–ø—Ç–∞
        detected_genre, genre_info = detect_genre(prompt)
        target_bpm = random.randint(*genre_info["bpm"])
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∑–∞–ø—Ä–æ—Å –∫ LLaMA3 —Å –∂–∞–Ω—Ä–æ–≤–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
        llama_prompt = f"""
        Create a detailed music track structure for: "{prompt}"
        
        Detected genre: {detected_genre}
        Target BPM range: {genre_info["bpm"][0]}-{genre_info["bpm"][1]}
        Core instruments: {", ".join(genre_info["core_instruments"])}
        
        Return JSON with:
        - tempo (BPM number, prefer {target_bpm})
        - genre (string, use "{detected_genre}")
        - mood (array of strings)
        - structure (array of sections with type, start_time, duration)
        - recommended_instruments (array from genre-specific instruments)
        - mastering_style (string, use "{genre_info["mastering_style"]}")
        
        Structure types for {detected_genre}: intro, verse, hook, bridge, outro, build, drop, break
        Make realistic timing in seconds, total duration should be 60-120 seconds.
        
        Return only valid JSON, no other text.
        """
        
        # –ó–∞–ø—É—Å–∫ ollama
        result = subprocess.run([
            'ollama', 'run', 'llama3-music'
        ], input=llama_prompt, capture_output=True, text=True, encoding='utf-8')
        
        if result.returncode == 0:
            try:
                # –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
                response_text = result.stdout.strip()
                start_idx = response_text.find('{')
                end_idx = response_text.rfind('}') + 1
                if start_idx >= 0 and end_idx > start_idx:
                    json_text = response_text[start_idx:end_idx]
                    structure = json.loads(json_text)
                    logging.info(f"‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–ª—É—á–µ–Ω–∞ –æ—Ç LLaMA3 –¥–ª—è –∂–∞–Ω—Ä–∞ {detected_genre}")
                    return structure
                else:
                    logging.error("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω JSON –≤ –æ—Ç–≤–µ—Ç–µ LLaMA3")
            except json.JSONDecodeError as e:
                logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –æ—Ç LLaMA3: {e}")
        else:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ LLaMA3: {result.stderr}")
    
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∫ LLaMA3: {e}")
    
    # –§–æ–ª–±–µ–∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π
    logging.warning(f"‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ñ–æ–ª–±–µ–∫ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –∂–∞–Ω—Ä–∞ {detected_genre}")
    detected_genre, genre_info = detect_genre(prompt)
    target_bpm = random.randint(*genre_info["bpm"])
    
    return {
        "tempo": target_bpm,
        "genre": detected_genre,
        "mood": ["energetic"],
        "mastering_style": genre_info["mastering_style"],
        "structure": [
            {"type": "intro", "start_time": 0, "duration": 8},
            {"type": "verse", "start_time": 8, "duration": 16},
            {"type": "hook", "start_time": 24, "duration": 16},
            {"type": "verse", "start_time": 40, "duration": 16},
            {"type": "hook", "start_time": 56, "duration": 16},
            {"type": "outro", "start_time": 72, "duration": 8}
        ],
        "recommended_instruments": genre_info["core_instruments"] + genre_info["optional_instruments"][:2]
    }


def query_mastering_prompt(original_prompt, mastering_purpose="personal"):
    """–ó–∞–ø—Ä–æ—Å –∫ LLaMA3 –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ–º–ø—Ç–∞ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞"""
    try:
        import subprocess
        
        purpose_descriptions = {
            "freelance": "–ø—Ä–æ–¥–∞–∂–∞ –Ω–∞ –∑–∞–∫–∞–∑ —á–µ—Ä–µ–∑ —Ñ—Ä–∏–ª–∞–Ω—Å –±–∏—Ä–∂—É, –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ",
            "professional": "–ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø—Ä–æ–¥–∞–∫—à–Ω –≤ –∫–∏–Ω–æ –∏–Ω–¥—É—Å—Ç—Ä–∏–∏, –∫–∏–Ω–æ—à–Ω—ã–π —Å–∞—É–Ω–¥—Ç—Ä–µ–∫",
            "personal": "–¥–ª—è —Å–µ–±—è, –¥–æ–º–∞—à–Ω–µ–µ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏–µ",
            "family": "–º–æ–Ω—Ç–∞–∂ –¥–ª—è —Å–µ–º—å–∏, –¥–æ–º–∞—à–Ω–µ–µ –≤–∏–¥–µ–æ"
        }
        
        purpose_desc = purpose_descriptions.get(mastering_purpose, "—É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ")
        
        llama_prompt = f"""
        Create a mastering and post-processing prompt for music track: "{original_prompt}"
        
        Purpose: {purpose_desc}
        
        Return JSON with modern mastering effects and parameters:
        - eq_settings (object with low, mid, high adjustments)
        - compression (object with ratio, attack, release)
        - reverb (object with type, room_size, wet_level)
        - stereo_enhancement (object with width, imaging)
        - harmonic_enhancement (object with saturation, warmth)
        - limiter (object with threshold, ceiling)
        - creative_fx (array of modern effects like "tape_saturation", "vintage_compressor", "stereo_imaging")
        - overall_character (string describing the mastering approach)
        
        Make it sound professional and modern for {purpose_desc}.
        Return only valid JSON, no other text.
        """
        
        result = subprocess.run([
            'ollama', 'run', 'llama3-music'
        ], input=llama_prompt, capture_output=True, text=True, encoding='utf-8')
        
        if result.returncode == 0:
            try:
                response_text = result.stdout.strip()
                start_idx = response_text.find('{')
                end_idx = response_text.rfind('}') + 1
                if start_idx >= 0 and end_idx > start_idx:
                    json_text = response_text[start_idx:end_idx]
                    mastering_config = json.loads(json_text)
                    logging.info(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞ –ø–æ–ª—É—á–µ–Ω –¥–ª—è —Ü–µ–ª–∏: {mastering_purpose}")
                    return mastering_config
            except json.JSONDecodeError as e:
                logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {e}")
        else:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ LLaMA3 –¥–ª—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {result.stderr}")
    
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞ –∫ LLaMA3: {e}")
    
    # –§–æ–ª–±–µ–∫ –∫–æ–Ω—Ñ–∏–≥ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
    logging.warning("‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ñ–æ–ª–±–µ–∫ –∫–æ–Ω—Ñ–∏–≥ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞")
    fallback_configs = {
        "freelance": {
            "eq_settings": {"low": 2, "mid": 0, "high": 3},
            "compression": {"ratio": 3.5, "attack": 5, "release": 100},
            "reverb": {"type": "hall", "room_size": 0.3, "wet_level": 0.15},
            "stereo_enhancement": {"width": 120, "imaging": "enhanced"},
            "harmonic_enhancement": {"saturation": "tube", "warmth": 0.3},
            "limiter": {"threshold": -1.5, "ceiling": -0.1},
            "creative_fx": ["tape_saturation", "vintage_compressor", "stereo_imaging"],
            "overall_character": "punchy commercial sound with modern loudness"
        },
        "professional": {
            "eq_settings": {"low": 1, "mid": -0.5, "high": 2},
            "compression": {"ratio": 2.5, "attack": 10, "release": 150},
            "reverb": {"type": "cinematic_hall", "room_size": 0.7, "wet_level": 0.25},
            "stereo_enhancement": {"width": 110, "imaging": "natural"},
            "harmonic_enhancement": {"saturation": "analog", "warmth": 0.4},
            "limiter": {"threshold": -3, "ceiling": -0.5},
            "creative_fx": ["analog_console", "tape_compression", "tube_warmth"],
            "overall_character": "cinematic professional sound with depth and space"
        },
        "personal": {
            "eq_settings": {"low": 0, "mid": 0, "high": 1},
            "compression": {"ratio": 2, "attack": 15, "release": 200},
            "reverb": {"type": "room", "room_size": 0.2, "wet_level": 0.1},
            "stereo_enhancement": {"width": 100, "imaging": "natural"},
            "harmonic_enhancement": {"saturation": "clean", "warmth": 0.2},
            "limiter": {"threshold": -6, "ceiling": -1},
            "creative_fx": ["gentle_compression", "smooth_eq"],
            "overall_character": "clean natural sound for home listening"
        },
        "family": {
            "eq_settings": {"low": 3, "mid": 2, "high": 2},
            "compression": {"ratio": 4, "attack": 3, "release": 80},
            "reverb": {"type": "bright_room", "room_size": 0.25, "wet_level": 0.12},
            "stereo_enhancement": {"width": 115, "imaging": "wide"},
            "harmonic_enhancement": {"saturation": "bright", "warmth": 0.25},
            "limiter": {"threshold": -2, "ceiling": -0.2},
            "creative_fx": ["brightness_enhancer", "vocal_clarity", "bass_punch"],
            "overall_character": "bright engaging sound perfect for family content"
        }
    }
    
    return fallback_configs.get(mastering_purpose, fallback_configs["personal"])


def apply_smart_mastering(audio_segment, mastering_config):
    """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —É–º–Ω–æ–≥–æ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ñ–∏–≥–∞ –æ—Ç LLaMA3"""
    try:
        logging.info("üéõÔ∏è –ü—Ä–∏–º–µ–Ω—è—é —É–º–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥...")
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        eq_settings = mastering_config.get("eq_settings", {})
        compression = mastering_config.get("compression", {})
        reverb = mastering_config.get("reverb", {})
        stereo_enhancement = mastering_config.get("stereo_enhancement", {})
        harmonic_enhancement = mastering_config.get("harmonic_enhancement", {})
        limiter = mastering_config.get("limiter", {})
        creative_fx = mastering_config.get("creative_fx", [])
        
        mastered = audio_segment
        
        # 1. EQ –æ–±—Ä–∞–±–æ—Ç–∫–∞
        low_gain = eq_settings.get("low", 0)
        mid_gain = eq_settings.get("mid", 0)
        high_gain = eq_settings.get("high", 0)
        
        if low_gain != 0:
            mastered = mastered.low_pass_filter(8000).overlay(
                mastered.high_pass_filter(80) + low_gain
            )
            logging.info(f"  üéöÔ∏è Low EQ: {low_gain:+.1f}dB")
        
        if high_gain != 0:
            mastered = mastered.high_pass_filter(80).overlay(
                mastered.low_pass_filter(8000) + high_gain
            )
            logging.info(f"  üéöÔ∏è High EQ: {high_gain:+.1f}dB")
        
        # 2. –ö–æ–º–ø—Ä–µ—Å—Å–∏—è (—Å–∏–º—É–ª—è—Ü–∏—è —á–µ—Ä–µ–∑ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—é –∏ –ª–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)
        ratio = compression.get("ratio", 2)
        if ratio > 1:
            # –ú—è–≥–∫–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è —á–µ—Ä–µ–∑ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—é
            peak_level = mastered.max_dBFS
            if peak_level > -6:
                compress_amount = min(6, (peak_level + 6) / ratio)
                mastered = mastered - compress_amount
                logging.info(f"  üóúÔ∏è –ö–æ–º–ø—Ä–µ—Å—Å–∏—è: {ratio}:1, —Å–Ω–∏–∂–µ–Ω–∏–µ {compress_amount:.1f}dB")
        
        # 3. –ì–∞—Ä–º–æ–Ω–∏—á–µ—Å–∫–∏–µ —É–ª—É—á—à–µ–Ω–∏—è
        saturation_type = harmonic_enhancement.get("saturation", "clean")
        warmth = harmonic_enhancement.get("warmth", 0)
        
        if saturation_type != "clean" and warmth > 0:
            # –°–∏–º—É–ª—è—Ü–∏—è —Ç–µ–ø–ª–æ—Ç—ã —á–µ—Ä–µ–∑ –æ—á–µ–Ω—å –ª—ë–≥–∫–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞
            warmth_boost = warmth * 2  # dB
            mastered = mastered.low_pass_filter(12000) + warmth_boost
            logging.info(f"  üî• {saturation_type.title()} saturation: {warmth:.1f}")
        
        # 4. –°—Ç–µ—Ä–µ–æ —É–ª—É—á—à–µ–Ω–∏—è
        width = stereo_enhancement.get("width", 100)
        if width != 100:
            # –°–∏–º—É–ª—è—Ü–∏—è —á–µ—Ä–µ–∑ –º–æ–Ω–æ/—Å—Ç–µ—Ä–µ–æ –º–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏–µ
            if mastered.channels == 2:
                width_factor = width / 100
                if width_factor > 1:
                    # –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Å—Ç–µ—Ä–µ–æ
                    logging.info(f"  üé≠ –°—Ç–µ—Ä–µ–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ: {width}%")
                elif width_factor < 1:
                    # –°—É–∂–µ–Ω–∏–µ —Å—Ç–µ—Ä–µ–æ
                    mono_component = mastered.set_channels(1).set_channels(2)
                    mastered = mastered.overlay(mono_component - 6)
                    logging.info(f"  üé≠ –°—Ç–µ—Ä–µ–æ —Å—É–∂–µ–Ω–∏–µ: {width}%")
        
        # 5. –õ–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
        threshold = limiter.get("threshold", -3)
        ceiling = limiter.get("ceiling", -0.1)
        
        if mastered.max_dBFS > threshold:
            # –ú—è–≥–∫–æ–µ –ª–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
            over_threshold = mastered.max_dBFS - threshold
            if over_threshold > 0:
                limit_reduction = min(over_threshold * 0.7, mastered.max_dBFS - ceiling)
                mastered = mastered - limit_reduction
                logging.info(f"  üöß –õ–∏–º–∏—Ç–µ—Ä: –ø–æ—Ä–æ–≥ {threshold}dB, –ø–æ—Ç–æ–ª–æ–∫ {ceiling}dB")
        
        # 6. –ö—Ä–µ–∞—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
        for fx in creative_fx:
            if "tape" in fx.lower():
                # –°–∏–º—É–ª—è—Ü–∏—è –ª–µ–Ω—Ç–æ—á–Ω–æ–≥–æ –Ω–∞—Å—ã—â–µ–Ω–∏—è
                mastered = mastered + 0.5  # –õ—ë–≥–∫–∏–π –ø–æ–¥—ä—ë–º
                logging.info(f"  üìº {fx}")
            elif "vintage" in fx.lower():
                # –í–∏–Ω—Ç–∞–∂–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
                mastered = mastered.high_pass_filter(60).low_pass_filter(15000)
                logging.info(f"  üï∞Ô∏è {fx}")
            elif "stereo" in fx.lower():
                # –°—Ç–µ—Ä–µ–æ –æ–±—Ä–∞–±–æ—Ç–∫–∞
                logging.info(f"  üéµ {fx}")
            elif "brightness" in fx.lower():
                # –Ø—Ä–∫–æ—Å—Ç—å
                mastered = mastered.high_pass_filter(100) + 1
                logging.info(f"  ‚ú® {fx}")
            elif "bass" in fx.lower():
                # –ë–∞—Å–æ–≤—ã–π —É–¥–∞—Ä
                mastered = mastered.low_pass_filter(200) + 1.5
                logging.info(f"  ü•Å {fx}")
        
        # 7. –§–∏–Ω–∞–ª—å–Ω–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
        target_level = -1 if "freelance" in str(mastering_config) else -3
        if mastered.max_dBFS < target_level - 6:
            normalize_gain = target_level - mastered.max_dBFS - 1
            mastered = mastered + normalize_gain
            logging.info(f"  üìä –§–∏–Ω–∞–ª—å–Ω–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è: {normalize_gain:+.1f}dB –¥–æ {target_level}dB")
        
        character = mastering_config.get("overall_character", "professional mastering")
        logging.info(f"‚úÖ –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥ –∑–∞–≤–µ—Ä—à—ë–Ω: {character}")
        
        return mastered
        
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {e}")
        # –§–æ–ª–±–µ–∫ - –ø—Ä–æ—Å—Ç–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
        return effects.normalize(audio_segment)


class WaveDreamLauncher:
    """–ì–ª–∞–≤–Ω—ã–π –ª–∞—É–Ω—á–µ—Ä WaveDream Enhanced —Å –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–µ–π –∏ —É–º–Ω—ã–º –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–æ–º"""
    
    def __init__(self):
        self.config = Config()
        self.setup_logging()
    
    def setup_logging(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
        logging.basicConfig(
            level=getattr(logging, self.config.LOGGING["level"]),
            format=self.config.LOGGING["format"],
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler(self.config.LOGGING["file"], encoding='utf-8')
            ]
        )
    
    def run_enhanced_full_chain(self, prompt, sample_dir, output_dir, mastering_purpose="personal", export_stems=False):
        """
        –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ü–µ–ø–æ—á–∫–∞: LLaMA3 ‚Üí MusicGen ‚Üí Stem Mix ‚Üí Merged ‚Üí MusicGen Fix ‚Üí Smart Mastering
        """
        os.makedirs(output_dir, exist_ok=True)
        
        logging.info(f"\nüöÄ –ó–∞–ø—É—Å–∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Ü–µ–ø–æ—á–∫–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
        logging.info(f"üìù –ü—Ä–æ–º–ø—Ç: '{prompt}'")
        logging.info(f"üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ: {mastering_purpose}")
        logging.info(f"üìÅ –°—ç–º–ø–ª—ã: {sample_dir}")
        logging.info(f"üìÅ –í—ã–≤–æ–¥: {output_dir}")
        
        try:
            # === 1. –î–µ—Ç–µ–∫—Ü–∏—è –∂–∞–Ω—Ä–∞ –∏–∑ –ø—Ä–æ–º–ø—Ç–∞ ===
            detected_genre, genre_info = detect_genre(prompt)
            logging.info(f"üé≠ –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∞–Ω—Ä: {detected_genre}")
            logging.info(f"üéµ BPM –¥–∏–∞–ø–∞–∑–æ–Ω: {genre_info['bpm']}")
            logging.info(f"üéõÔ∏è –°—Ç–∏–ª—å –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {genre_info['mastering_style']}")
            
            # === 2. –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ—Ç LLaMA3 —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π ===
            logging.info("üß† –ó–∞–ø—Ä–æ—Å –∂–∞–Ω—Ä–æ–≤–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫ LLaMA3...")
            structure_data = query_structured_music(prompt)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É
            structure_path = os.path.join(output_dir, "enhanced_structure.json")
            structure_data["detected_genre"] = detected_genre
            structure_data["genre_info"] = genre_info
            
            with open(structure_path, "w", encoding="utf-8") as f:
                json.dump(structure_data, f, indent=2, ensure_ascii=False)
            logging.info(f"üìÑ –ñ–∞–Ω—Ä–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {structure_path}")
            
            tempo = structure_data.get("tempo", random.randint(*genre_info["bpm"]))
            genre = structure_data.get("genre", detected_genre)
            structure = structure_data.get("structures", [])
            mastering_style = structure_data.get("mastering_style", genre_info["mastering_style"])
            
            # –†–∞—Å—á–µ—Ç –æ–±—â–µ–π –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            total_duration = max([s.get("start_time", 0) + s.get("duration", 0) for s in structure])
            if total_duration < 30:
                total_duration = 60
            
            logging.info(f"üéµ –¢–µ–º–ø: {tempo} BPM, –ñ–∞–Ω—Ä: {genre}, –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {total_duration}—Å")
            
            # === 3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Å–Ω–æ–≤—ã —á–µ—Ä–µ–∑ MusicGen ===
            logging.info("üéº –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∂–∞–Ω—Ä–æ–≤–æ–π –æ—Å–Ω–æ–≤—ã —á–µ—Ä–µ–∑ MusicGen...")
            genre_enhanced_prompt = f"{prompt} {genre} style {tempo}bpm {mastering_style}"
            musicgen_wav, sr = generate_music(genre_enhanced_prompt, duration=total_duration)
            musicgen_path = os.path.join(output_dir, "01_musicgen_genre_base.wav")
            sf.write(musicgen_path, musicgen_wav.squeeze().numpy(), sr, format="WAV")
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–∞–∫ AudioSegment
            musicgen_base = AudioSegment.from_wav(musicgen_path)
            logging.info(f"‚úÖ MusicGen –∂–∞–Ω—Ä–æ–≤–∞—è –æ—Å–Ω–æ–≤–∞: {len(musicgen_base)/1000:.1f}—Å")
            
            # === 4. –°–æ–∑–¥–∞–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤–æ–≥–æ Stem Mix ===
            logging.info(f"üîç –°–æ–∑–¥–∞–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤–æ–≥–æ Stem Mix –¥–ª—è {genre}...")
            sample_picker = EnhancedSamplePicker(sample_dir)
            
            # –°–æ–∑–¥–∞—ë–º –ø—É—Å—Ç–æ–π stem mix
            stem_mix = AudioSegment.silent(duration=len(musicgen_base))
            used_samples = []
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é —Å–µ–∫—Ü–∏—é —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π
            for section in structure:
                section_type = section.get("type", "unknown")
                start_time = section.get("start_time", 0)
                duration = section.get("duration", 8)
                
                start_ms = int(start_time * 1000)
                duration_ms = int(duration * 1000)
                
                logging.info(f"üéØ {genre.title()} —Å–µ–∫—Ü–∏—è [{section_type}]: {start_time}—Å -> {duration}—Å")
                
                # –ü–æ–¥–±–∏—Ä–∞–µ–º —Å—ç–º–ø–ª—ã –¥–ª—è —Å–µ–∫—Ü–∏–∏ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π
                section_samples = sample_picker.pick_samples_for_genre_structure(
                    section, tempo, genre, mood_hint=structure_data.get("mood", [])
                )
                
                # –†–∞–∑–º–µ—â–∞–µ–º —Å—ç–º–ø–ª—ã –≤ stem mix
                for sample_info in section_samples:
                    try:
                        sample_path = sample_info["path"]
                        instrument_role = sample_info.get("instrument_role", "unknown")
                        
                        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å—ç–º–ø–ª
                        sample_audio = AudioSegment.from_file(sample_path)
                        
                        # –ü–æ–¥–≥–æ–Ω—è–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ–¥ —Å–µ–∫—Ü–∏—é
                        if sample_info.get("category") == "loop":
                            # –î–ª—è –ª—É–ø–æ–≤ - –∑–∞—Ü–∏–∫–ª–∏–≤–∞–µ–º –∏–ª–∏ –æ–±—Ä–µ–∑–∞–µ–º
                            if len(sample_audio) < duration_ms:
                                repeats = (duration_ms // len(sample_audio)) + 1
                                sample_audio = (sample_audio * repeats)[:duration_ms]
                            else:
                                sample_audio = sample_audio[:duration_ms]
                        else:
                            # –î–ª—è one-shots - —Ä–∞–∑–º–µ—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å + —Ç–∏—à–∏–Ω–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                            if len(sample_audio) > duration_ms:
                                sample_audio = sample_audio[:duration_ms]
                            elif len(sample_audio) < duration_ms:
                                pad_duration = duration_ms - len(sample_audio)
                                sample_audio += AudioSegment.silent(duration=pad_duration)
                        
                        # –ü—Ä–∏–º–µ–Ω—è–µ–º –∂–∞–Ω—Ä–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ volume –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                        genre_volume_map = {
                            "trap": {"kick": -2, "808": -2, "snare": -4, "trap_hat": -8, "bell": -10},
                            "phonk": {"kick_808": -1, "snare": -5, "phonk_cowbell": -6, "vinyl_fx": -12},
                            "lofi": {"soft_snare": -8, "rim": -10, "vinyl_fx": -15, "piano_soft": -6},
                            "dnb": {"snare_dnb": -3, "reese_bass": -2, "break": -4, "pad": -10},
                            "techno": {"kick_techno": -1, "tech_bass": -3, "hat": -8, "modular": -8},
                            "house": {"kick": -2, "clap": -5, "hat": -8, "pluck": -6},
                            "ambient": {"pad": -6, "drone": -8, "texture": -12, "bell": -10},
                            "cinematic": {"braam": -2, "string_ensemble": -4, "choir": -6, "impact": -3}
                        }
                        
                        volume = genre_volume_map.get(genre, {}).get(instrument_role, -6)
                        sample_audio = sample_audio + volume
                        
                        # –ù–∞–∫–ª–∞–¥—ã–≤–∞–µ–º –Ω–∞ stem mix –≤ –Ω—É–∂–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
                        stem_mix = stem_mix.overlay(sample_audio, position=start_ms)
                        
                        used_samples.append({
                            "section": section_type,
                            "instrument": instrument_role,
                            "file": sample_info["filename"],
                            "genre": genre,
                            "start_time": start_time,
                            "duration": duration,
                            "volume": volume
                        })
                        
                        logging.info(f"  ‚úÖ {instrument_role}: {sample_info['filename']} ({volume:+.1f}dB)")
                    
                    except Exception as e:
                        logging.error(f"  ‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—ç–º–ø–ª–∞: {e}")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∂–∞–Ω—Ä–æ–≤—ã–π stem mix
            stem_mix_path = os.path.join(output_dir, f"02_{genre}_stem_mix.wav")
            stem_mix.export(stem_mix_path, format="wav")
            logging.info(f"üéõÔ∏è {genre.title()} Stem Mix –≥–æ—Ç–æ–≤: {stem_mix_path}")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã—Ö —Å—ç–º–ø–ª–∞—Ö
            samples_info_path = os.path.join(output_dir, "used_samples_enhanced.json")
            with open(samples_info_path, "w", encoding="utf-8") as f:
                json.dump(used_samples, f, indent=2, ensure_ascii=False)
            
            # === 5. –°–æ–∑–¥–∞–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤–æ–≥–æ Merged Mix ===
            logging.info(f"üéöÔ∏è –°–æ–∑–¥–∞–Ω–∏–µ {genre.title()} Merged Mix...")
            
            # –ñ–∞–Ω—Ä–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ–µ –º–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏–µ
            genre_mix_settings = {
                "trap": {"musicgen": -4, "stem": -5},
                "phonk": {"musicgen": -3, "stem": -6},
                "lofi": {"musicgen": -5, "stem": -8},
                "dnb": {"musicgen": -2, "stem": -4},
                "techno": {"musicgen": -3, "stem": -5},
                "house": {"musicgen": -4, "stem": -6},
                "ambient": {"musicgen": -6, "stem": -10},
                "cinematic": {"musicgen": -2, "stem": -4}
            }
            
            mix_settings = genre_mix_settings.get(genre, {"musicgen": -3, "stem": -6})
            
            musicgen_level = mix_settings["musicgen"]
            stem_level = mix_settings["stem"]
            
            merged_mix = (musicgen_base + musicgen_level).overlay(stem_mix + stem_level)
            merged_path = os.path.join(output_dir, f"03_{genre}_merged_mix.wav")
            merged_mix.export(merged_path, format="wav")
            logging.info(f"üîÑ {genre.title()} Merged Mix –≥–æ—Ç–æ–≤: {merged_path}")
            
            # === 6. –§–∏–Ω–∞–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —á–µ—Ä–µ–∑ MusicGen (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ guidance_scale) ===
            logging.info("üé® –§–∏–Ω–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ —á–µ—Ä–µ–∑ MusicGen...")
            
            # –°–æ–∑–¥–∞—ë–º —É–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ merged mix (–ë–ï–ó guidance_scale!)
            final_prompt = f"{prompt} {genre} professional mix mastered high quality {mastering_style}"
            
            final_musicgen_wav, sr = generate_music(
                final_prompt, 
                duration=total_duration
                # –£–±–∏—Ä–∞–µ–º guidance_scale - –µ–≥–æ –Ω–µ—Ç –≤ —Ñ—É–Ω–∫—Ü–∏–∏!
            )
            
            final_base_path = os.path.join(output_dir, "04_final_musicgen_fix.wav")
            sf.write(final_base_path, final_musicgen_wav.squeeze().numpy(), sr, format="WAV")
            logging.info(f"üéº –§–∏–Ω–∞–ª—å–Ω–∞—è MusicGen –æ–±—Ä–∞–±–æ—Ç–∫–∞: {final_base_path}")
            
            # === 7. –ù–û–í–´–ô –≠–¢–ê–ü: –ó–∞–ø—Ä–æ—Å –≤—Ç–æ—Ä–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞ ===
            logging.info("üé§ –ó–∞–ø—Ä–æ—Å –∫–æ–Ω—Ñ–∏–≥–∞ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞ –∫ LLaMA3...")
            mastering_config = query_mastering_prompt(prompt, mastering_purpose)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
            mastering_config_path = os.path.join(output_dir, "mastering_config.json")
            with open(mastering_config_path, "w", encoding="utf-8") as f:
                json.dump(mastering_config, f, indent=2, ensure_ascii=False)
            logging.info(f"üìã –ö–æ–Ω—Ñ–∏–≥ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {mastering_config_path}")
            
            # === 8. –ù–û–í–´–ô –≠–¢–ê–ü: –£–º–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ ===
            logging.info("üéõÔ∏è –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —É–º–Ω–æ–≥–æ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞...")
            
            # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –º–∏–∫—Å –¥–ª—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
            final_for_mastering = AudioSegment.from_wav(final_base_path)
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —É–º–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–Ω—Ñ–∏–≥–∞ –æ—Ç LLaMA3
            mastered_track = apply_smart_mastering(final_for_mastering, mastering_config)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞—Å—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç—Ä–µ–∫
            final_mastered_path = os.path.join(output_dir, f"05_FINAL_{genre}_{mastering_purpose}_MASTERED.wav")
            mastered_track.export(final_mastered_path, format="wav")
            logging.info(f"üéâ –ú–∞—Å—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç—Ä–µ–∫ –≥–æ—Ç–æ–≤: {final_mastered_path}")
            
            # === 9. –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è ===
            logging.info("üîç –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –º–∞—Å—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞...")
            verification_result = verify_mix(final_mastered_path)
            
            if verification_result.get("ok", False):
                logging.info("‚úÖ –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è –ø—Ä–æ–π–¥–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
            else:
                logging.warning(f"‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã –ø—Ä–∏ –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏: {verification_result.get('reason', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}")
            
            # === 10. –≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –≤–µ—Ä—Å–∏–π (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) ===
            if export_stems:
                logging.info("üíæ –≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –≤–µ—Ä—Å–∏–π...")
                stems_dir = os.path.join(output_dir, "exported_all_versions")
                os.makedirs(stems_dir, exist_ok=True)
                
                # –ö–æ–ø–∏—Ä—É–µ–º –≤—Å–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
                import shutil
                stem_files = [
                    ("01_musicgen_genre_base.wav", f"01_MusicGen_{genre.title()}_Base.wav"),
                    (f"02_{genre}_stem_mix.wav", f"02_{genre.title()}_Stem_Mix.wav"), 
                    (f"03_{genre}_merged_mix.wav", f"03_{genre.title()}_Merged_Mix.wav"),
                    ("04_final_musicgen_fix.wav", f"04_Final_MusicGen_Fix.wav"),
                    (f"05_FINAL_{genre}_{mastering_purpose}_MASTERED.wav", f"05_FINAL_{genre.title()}_{mastering_purpose.upper()}_MASTERED.wav")
                ]
                
                for src_file, dst_file in stem_files:
                    src_path = os.path.join(output_dir, src_file)
                    dst_path = os.path.join(stems_dir, dst_file)
                    if os.path.exists(src_path):
                        shutil.copy2(src_path, dst_path)
                        logging.info(f"  üìÅ {dst_file} —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω")
                
                # –¢–∞–∫–∂–µ –∫–æ–ø–∏—Ä—É–µ–º –∫–æ–Ω—Ñ–∏–≥–∏
                shutil.copy2(structure_path, os.path.join(stems_dir, "structure_config.json"))
                shutil.copy2(mastering_config_path, os.path.join(stems_dir, "mastering_config.json"))
                shutil.copy2(samples_info_path, os.path.join(stems_dir, "used_samples.json"))
                
                logging.info(f"‚úÖ –í—Å–µ –≤–µ—Ä—Å–∏–∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤: {stems_dir}")
            
            # === 11. –§–∏–Ω–∞–ª—å–Ω—ã–π –¥–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç ===
            logging.info("=" * 70)
            logging.info("üéâ –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –¶–ï–ü–û–ß–ö–ê –ó–ê–í–ï–†–®–ï–ù–ê!")
            logging.info("=" * 70)
            logging.info(f"üìÅ –ú–∞—Å—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {final_mastered_path}")
            logging.info(f"‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {len(mastered_track)/1000:.1f} —Å–µ–∫—É–Ω–¥")
            logging.info(f"üé≠ –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∞–Ω—Ä: {detected_genre}")
            logging.info(f"üéµ –¢–µ–º–ø: {tempo} BPM")
            logging.info(f"üéõÔ∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Å—ç–º–ø–ª–æ–≤: {len(used_samples)}")
            logging.info(f"üìä –°–µ–∫—Ü–∏–π –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ: {len(structure)}")
            logging.info(f"üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {mastering_purpose}")
            logging.info(f"üîß –°—Ç–∏–ª—å –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {mastering_style}")
            
            mastering_character = mastering_config.get("overall_character", "professional")
            logging.info(f"üéöÔ∏è –•–∞—Ä–∞–∫—Ç–µ—Ä –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {mastering_character}")
            
            if export_stems:
                logging.info(f"üíæ –í—Å–µ –≤–µ—Ä—Å–∏–∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã: {stems_dir}")
            
            logging.info("üéµ –≠—Ç–∞–ø—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏:")
            logging.info("  1. ‚úÖ –ñ–∞–Ω—Ä–æ–≤–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è –∏–∑ –ø—Ä–æ–º–ø—Ç–∞")  
            logging.info("  2. ‚úÖ LLaMA3 —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π")
            logging.info("  3. ‚úÖ MusicGen –∂–∞–Ω—Ä–æ–≤–∞—è –æ—Å–Ω–æ–≤–∞")
            logging.info("  4. ‚úÖ –ñ–∞–Ω—Ä–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π Stem Mix")
            logging.info("  5. ‚úÖ –ñ–∞–Ω—Ä–æ–≤–æ–µ –º–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏–µ")
            logging.info("  6. ‚úÖ MusicGen —Ñ–∏–Ω–∞–ª—å–Ω–∞—è –¥–æ—Ä–∞–±–æ—Ç–∫–∞")
            logging.info("  7. ‚úÖ LLaMA3 –∫–æ–Ω—Ñ–∏–≥ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞")
            logging.info("  8. ‚úÖ –£–º–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ —Å —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–º–∏ FX")
            logging.info("=" * 70)
            
            return final_mastered_path, structure_data, used_samples, mastering_config
            
        except Exception as e:
            logging.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Ü–µ–ø–æ—á–∫–µ: {e}")
            logging.error(f"üîç –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞: {traceback.format_exc()}")
            return None, None, None, None
    
    def run_interactive_mode(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏"""
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üéµ WaveDream Enhanced Pro - Genre Detection & Smart Mastering Edition üéµ ‚ïë
‚ïë LLaMA3 ‚Üí MusicGen ‚Üí Genre Stem Mix ‚Üí Merged ‚Üí Fix ‚Üí Smart Mastering     ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        errors = self.config.validate_config()
        if errors:
            print("‚ùå –û—à–∏–±–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:")
            for error in errors:
                print(f"  ‚Ä¢ {error}")
            return
        
        sample_dir = self.config.get_sample_dir()
        print(f"üìÇ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å—ç–º–ø–ª–æ–≤: {sample_dir}")
        
        while True:
            print("\n" + "="*80)
            print("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:")
            print("1. üöÄ –ü–æ–ª–Ω–∞—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ü–µ–ø–æ—á–∫–∞ (LLaMA3 + –∂–∞–Ω—Ä—ã + –º–∞—Å—Ç–µ—Ä–∏–Ω–≥)")
            print("2. üéº –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–µ–∫ (—Å—Ç–∞—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º)")
            print("3. üé≠ –¢–µ—Å—Ç –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–∏")
            print("4. üîç –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ–¥–±–æ—Ä —Å—ç–º–ø–ª–æ–≤ –ø–æ –∂–∞–Ω—Ä–∞–º")
            print("5. üìä –ê–Ω–∞–ª–∏–∑ –∏–Ω–¥–µ–∫—Å–∞ —Å—ç–º–ø–ª–æ–≤")
            print("6. üîÑ –ü–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å")
            print("7. üéõÔ∏è –¢–µ—Å—Ç –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞")
            print("8. ‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
            print("0. üö™ –í—ã—Ö–æ–¥")
            
            choice = input("\n–í–∞—à –≤—ã–±–æ—Ä: ").strip()
            
            if choice == "1":
                self.interactive_enhanced_generation()
            elif choice == "2":
                self.interactive_old_generation()
            elif choice == "3":
                self.interactive_genre_detection_test()
            elif choice == "4":
                self.interactive_test_genre_samples()
            elif choice == "5":
                self.interactive_analyze_index()
            elif choice == "6":
                self.interactive_rebuild_enhanced_index()
            elif choice == "7":
                self.interactive_test_mastering()
            elif choice == "8":
                self.interactive_settings()
            elif choice == "0":
                print("üëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!")
                break
            else:
                print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä")
    
    def interactive_enhanced_generation(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è"""
        print("\nüöÄ –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –¶–ï–ü–û–ß–ö–ê –ì–ï–ù–ï–†–ê–¶–ò–ò")
        print("-" * 50)
        print("–ñ–∞–Ω—Ä–æ–≤–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è + LLaMA3 + MusicGen + Smart Mastering")
        
        # –í–≤–æ–¥ –ø—Ä–æ–º–ø—Ç–∞
        prompt = input("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: ").strip()
        if not prompt:
            print("‚ùå –ü—Ä–æ–º–ø—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
            return
        
        # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è –∂–∞–Ω—Ä–∞ –¥–ª—è –ø–æ–∫–∞–∑–∞
        detected_genre, genre_info = detect_genre(prompt)
        print(f"\nüé≠ –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è –∂–∞–Ω—Ä–∞: {detected_genre}")
        print(f"üéµ BPM –¥–∏–∞–ø–∞–∑–æ–Ω: {genre_info['bpm']}")
        print(f"üéõÔ∏è –°—Ç–∏–ª—å –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {genre_info['mastering_style']}")
        
        confirm_genre = input(f"–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å –∂–∞–Ω—Ä–æ–º '{detected_genre}'? (Y/n): ").lower()
        if confirm_genre == 'n':
            available_genres = list(GENRE_INFO.keys())
            print(f"–î–æ—Å—Ç—É–ø–Ω—ã–µ –∂–∞–Ω—Ä—ã: {', '.join(available_genres)}")
            manual_genre = input("–í–≤–µ–¥–∏—Ç–µ –∂–∞–Ω—Ä –≤—Ä—É—á–Ω—É—é: ").strip().lower()
            if manual_genre in available_genres:
                # –ü–µ—Ä–µ–∑–∞–ø–∏—Å—ã–≤–∞–µ–º –ø—Ä–æ–º–ø—Ç —Å —è–≤–Ω—ã–º –∂–∞–Ω—Ä–æ–º
                prompt = f"{manual_genre} {prompt}"
                print(f"üìù –ü—Ä–æ–º–ø—Ç –æ–±–Ω–æ–≤–ª—ë–Ω: {prompt}")
        
        # –í—ã–±–æ—Ä –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
        print("\nüéØ –í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞:")
        print("1. –§—Ä–∏–ª–∞–Ω—Å (–∫–æ–º–º–µ—Ä—á–µ—Å–∫–∞—è –ø—Ä–æ–¥–∞–∂–∞)")
        print("2. –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π (–∫–∏–Ω–æ/–¢–í)")  
        print("3. –õ–∏—á–Ω–æ–µ (–¥–ª—è —Å–µ–±—è)")
        print("4. –°–µ–º–µ–π–Ω–æ–µ (–¥–æ–º–∞—à–Ω–µ–µ –≤–∏–¥–µ–æ)")
        
        purpose_choice = input("–í—ã–±–æ—Ä (1-4, Enter –¥–ª—è –ª–∏—á–Ω–æ–≥–æ): ").strip()
        purpose_map = {
            "1": "freelance",
            "2": "professional", 
            "3": "personal",
            "4": "family"
        }
        mastering_purpose = purpose_map.get(purpose_choice, "personal")
        print(f"üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ: {mastering_purpose}")
        
        # –í—ã–±–æ—Ä –≤—ã—Ö–æ–¥–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        output_dir = input("–í—ã—Ö–æ–¥–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è (Enter –¥–ª—è 'output_enhanced'): ").strip()
        if not output_dir:
            output_dir = f"output_enhanced_{detected_genre}_{mastering_purpose}"
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏
        print("\n–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏:")
        rebuild_index = input("–ü–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å –∏–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤? (y/N): ").lower().startswith('y')
        export_stems = input("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –≤–µ—Ä—Å–∏–∏? (Y/n): ").lower() != 'n'
        
        try:
            sample_dir = self.config.get_sample_dir()
            
            # –ü–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if rebuild_index:
                print("üîÑ –ü–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞...")
                picker = EnhancedSamplePicker(sample_dir)
                picker.index = picker.build_enhanced_index()
                picker.save_index(picker.index)
            
            # –ó–∞–ø—É—Å–∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Ü–µ–ø–æ—á–∫–∏
            print(f"\nüöÄ –ó–∞–ø—É—Å–∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π —Ü–µ–ø–æ—á–∫–∏ –¥–ª—è: '{prompt}'")
            print(f"üé≠ –ñ–∞–Ω—Ä: {detected_genre}, üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ: {mastering_purpose}")
            
            final_path, structure_data, used_samples, mastering_config = self.run_enhanced_full_chain(
                prompt, sample_dir, output_dir, mastering_purpose, export_stems
            )
            
            if final_path:
                print(f"\nüéâ –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê!")
                print(f"üìÅ –ú–∞—Å—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {final_path}")
                
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                if structure_data:
                    print(f"\nüìä –î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:")
                    print(f"  üé≠ –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∞–Ω—Ä: {structure_data.get('detected_genre', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
                    print(f"  üéµ –¢–µ–º–ø: {structure_data.get('tempo', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')} BPM")
                    print(f"  üéõÔ∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Å—ç–º–ø–ª–æ–≤: {len(used_samples) if used_samples else 0}")
                    print(f"  üìà –°–µ–∫—Ü–∏–π –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–µ: {len(structure_data.get('structure', []))}")
                    print(f"  üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {mastering_purpose}")
                    
                    if mastering_config:
                        print(f"  üéöÔ∏è –•–∞—Ä–∞–∫—Ç–µ—Ä –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {mastering_config.get('overall_character', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
                        print(f"  üîß –ö—Ä–µ–∞—Ç–∏–≤–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã: {', '.join(mastering_config.get('creative_fx', []))}")
                
                # –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏
                play_choice = input("\n–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç? (y/N): ").lower()
                if play_choice.startswith('y'):
                    try:
                        import platform
                        if platform.system() == "Windows":
                            os.system(f'start "" "{final_path}"')
                        elif platform.system() == "Darwin":  # macOS
                            os.system(f'open "{final_path}"')
                        else:  # Linux
                            os.system(f'xdg-open "{final_path}"')
                    except:
                        print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ")
            else:
                print("‚ùå –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å")
        
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–π —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
            print(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
    
    def interactive_genre_detection_test(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–∏"""
        print("\nüé≠ –¢–ï–°–¢ –ñ–ê–ù–†–û–í–û–ô –î–ï–¢–ï–ö–¶–ò–ò")
        print("-" * 40)
        
        test_prompts = [
            "dark aggressive trap 160bpm with vocal chops",
            "–º–µ–ª–æ–¥–∏—á–Ω—ã–π –ª–æ—É—Ñ–∞–π –¥–ª—è —É—á—ë–±—ã —Å –≤–∏–Ω—Ç–∞–∂–Ω—ã–º–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏",
            "liquid drum and bass neurofunk 174bpm",
            "–∞—Ç–º–æ—Å—Ñ–µ—Ä–Ω—ã–π —ç–º–±–∏–µ–Ω—Ç –∫–æ—Å–º–æ—Å –º–µ–¥–∏—Ç–∞—Ü–∏—è 70bpm",
            "phonk memphis cowbell drift aggressive",
            "—Ç–µ—Ö–Ω–æ –º–∏–Ω–∏–º–∞–ª 130bpm industrial warehouse",
            "cinematic epic trailer orchestral heroic",
            "house deep groove –ø–ª–∞–≤–Ω—ã–π bassline 124bpm"
        ]
        
        while True:
            print("\n–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (–∏–ª–∏ 'test' –¥–ª—è –∞–≤—Ç–æ—Ç–µ—Å—Ç–æ–≤, 'exit' –¥–ª—è –≤—ã—Ö–æ–¥–∞):")
            user_input = input("–ü—Ä–æ–º–ø—Ç: ").strip()
            
            if user_input.lower() == 'exit':
                break
            elif user_input.lower() == 'test':
                print("\nüß™ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï:")
                for i, test_prompt in enumerate(test_prompts, 1):
                    print(f"\n{i}. –ü—Ä–æ–º–ø—Ç: '{test_prompt}'")
                    detected_genre, genre_info = detect_genre(test_prompt)
                    print(f"   üé≠ –ñ–∞–Ω—Ä: {detected_genre}")
                    print(f"   üéµ BPM: {genre_info['bpm']}")
                    print(f"   üéõÔ∏è –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥: {genre_info['mastering_style']}")
                    print(f"   üéº –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: {', '.join(genre_info['core_instruments'][:3])}")
            elif user_input:
                print(f"\nüîç –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–º–ø—Ç–∞: '{user_input}'")
                detected_genre, genre_info = detect_genre(user_input)
                print(f"üé≠ –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∞–Ω—Ä: {detected_genre}")
                print(f"üéµ BPM –¥–∏–∞–ø–∞–∑–æ–Ω: {genre_info['bpm']}")
                print(f"üéõÔ∏è –°—Ç–∏–ª—å –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {genre_info['mastering_style']}")
                print(f"üéº –û—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: {', '.join(genre_info['core_instruments'])}")
                print(f"üéπ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: {', '.join(genre_info['optional_instruments'])}")
                print(f"üè∑Ô∏è –î–µ—Ñ–æ–ª—Ç–Ω—ã–µ —Ç–µ–≥–∏: {', '.join(genre_info['default_tags'][:5])}")
    
    def interactive_test_genre_samples(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–±–æ—Ä–∞ —Å—ç–º–ø–ª–æ–≤ –ø–æ –∂–∞–Ω—Ä–∞–º"""
        print("\nüß™ –¢–ï–°–¢ –ü–û–î–ë–û–†–ê –°–≠–ú–ü–õ–û–í –ü–û –ñ–ê–ù–†–ê–ú")
        print("-" * 45)
        
        sample_dir = self.config.get_sample_dir()
        picker = EnhancedSamplePicker(sample_dir)
        
        available_genres = list(GENRE_INFO.keys())
        print(f"–î–æ—Å—Ç—É–ø–Ω—ã–µ –∂–∞–Ω—Ä—ã: {', '.join(available_genres)}")
        
        while True:
            genre_input = input("–í–≤–µ–¥–∏—Ç–µ –∂–∞–Ω—Ä –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (–∏–ª–∏ 'exit'): ").strip().lower()
            if genre_input == 'exit':
                break
            
            if genre_input not in available_genres:
                print(f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∂–∞–Ω—Ä. –î–æ—Å—Ç—É–ø–Ω—ã–µ: {', '.join(available_genres)}")
                continue
            
            genre_info = GENRE_INFO[genre_input]
            target_tempo = random.randint(*genre_info["bpm"])
            
            print(f"\nüé≠ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–∞: {genre_input}")
            print(f"üéµ –¶–µ–ª–µ–≤–æ–π —Ç–µ–º–ø: {target_tempo} BPM")
            print(f"üéº –û—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: {', '.join(genre_info['core_instruments'])}")
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–±–æ—Ä —Å—ç–º–ø–ª–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
            for instrument in genre_info['core_instruments']:
                print(f"\nüéØ –ü–æ–∏—Å–∫ —Å—ç–º–ø–ª–æ–≤ –¥–ª—è: {instrument}")
                instrument_tags = expand_instrument_tags(instrument)
                print(f"   –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ç–µ–≥–∏: {', '.join(instrument_tags)}")
                
                results = picker.pick_samples_enhanced(
                    required_tags=instrument_tags,
                    target_tempo=target_tempo,
                    genre_hint=genre_input,
                    top_k=3
                )
                
                if results:
                    for i, sample in enumerate(results, 1):
                        print(f"   {i}. {sample['filename']}")
                        print(f"      –¢–µ–≥–∏: {sample.get('tags', [])}")
                        print(f"      –¢–µ–º–ø: {sample.get('tempo', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')} BPM")
                        print(f"      –ñ–∞–Ω—Ä—ã: {sample.get('genres', [])}")
                        print(f"      –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {sample.get('category', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
                else:
                    print("   ‚ùå –°–æ–≤–ø–∞–¥–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    def interactive_test_mastering(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞"""
        print("\nüéõÔ∏è –¢–ï–°–¢ –£–ú–ù–û–ì–û –ú–ê–°–¢–ï–†–ò–ù–ì–ê")
        print("-" * 35)
        
        # –¢–µ—Å—Ç –ø—Ä–æ–º–ø—Ç—ã –¥–ª—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
        test_cases = [
            ("aggressive trap dark", "freelance"),
            ("melodic lofi chill", "personal"),
            ("cinematic epic orchestral", "professional"),
            ("happy family song", "family")
        ]
        
        print("–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ—Å—Ç –∫–µ–π—Å:")
        for i, (prompt, purpose) in enumerate(test_cases, 1):
            print(f"{i}. '{prompt}' –¥–ª—è {purpose}")
        print("5. –í–≤–µ—Å—Ç–∏ —Å–≤–æ–π –ø—Ä–æ–º–ø—Ç")
        
        choice = input("–í—ã–±–æ—Ä (1-5): ").strip()
        
        if choice in ['1', '2', '3', '4']:
            test_prompt, test_purpose = test_cases[int(choice) - 1]
        elif choice == '5':
            test_prompt = input("–í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–ø—Ç: ").strip()
            if not test_prompt:
                return
            
            print("–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ:")
            print("1. freelance, 2. professional, 3. personal, 4. family")
            purpose_choice = input("–í—ã–±–æ—Ä (1-4): ").strip()
            purpose_map = {"1": "freelance", "2": "professional", "3": "personal", "4": "family"}
            test_purpose = purpose_map.get(purpose_choice, "personal")
        else:
            print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä")
            return
        
        print(f"\nüß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞:")
        print(f"üìù –ü—Ä–æ–º–ø—Ç: '{test_prompt}'")
        print(f"üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ: {test_purpose}")
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
        mastering_config = query_mastering_prompt(test_prompt, test_purpose)
        
        print(f"\nüéõÔ∏è –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞:")
        print(f"EQ: Low {mastering_config.get('eq_settings', {}).get('low', 0):+.1f}dB, "
              f"Mid {mastering_config.get('eq_settings', {}).get('mid', 0):+.1f}dB, "
              f"High {mastering_config.get('eq_settings', {}).get('high', 0):+.1f}dB")
        
        compression = mastering_config.get('compression', {})
        print(f"–ö–æ–º–ø—Ä–µ—Å—Å–∏—è: {compression.get('ratio', 2)}:1, "
              f"Attack {compression.get('attack', 10)}ms, "
              f"Release {compression.get('release', 100)}ms")
        
        reverb = mastering_config.get('reverb', {})
        print(f"–†–µ–≤–µ—Ä–±: {reverb.get('type', 'room')}, "
              f"Size {reverb.get('room_size', 0.3)}, "
              f"Wet {reverb.get('wet_level', 0.1)}")
        
        stereo = mastering_config.get('stereo_enhancement', {})
        print(f"–°—Ç–µ—Ä–µ–æ: Width {stereo.get('width', 100)}%, "
              f"Imaging {stereo.get('imaging', 'natural')}")
        
        creative_fx = mastering_config.get('creative_fx', [])
        print(f"–ö—Ä–µ–∞—Ç–∏–≤–Ω—ã–µ FX: {', '.join(creative_fx)}")
        
        character = mastering_config.get('overall_character', 'professional')
        print(f"–û–±—â–∏–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä: {character}")
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –∫–æ–Ω—Ñ–∏–≥
        test_config_path = f"test_mastering_{test_purpose}.json"
        with open(test_config_path, 'w', encoding='utf-8') as f:
            json.dump(mastering_config, f, indent=2, ensure_ascii=False)
        print(f"\nüíæ –¢–µ—Å—Ç–æ–≤—ã–π –∫–æ–Ω—Ñ–∏–≥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {test_config_path}")
    
    def interactive_rebuild_enhanced_index(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞"""
        print("\nüîÑ –ü–ï–†–ï–°–û–ó–î–ê–ù–ò–ï –†–ê–°–®–ò–†–ï–ù–ù–û–ì–û –ò–ù–î–ï–ö–°–ê")
        print("-" * 45)
        
        confirm = input("–≠—Ç–æ –∑–∞–π–º—ë—Ç –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±–æ–ª—å—à–µ –≤—Ä–µ–º–µ–Ω–∏. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å? (y/N): ")
        if not confirm.lower().startswith('y'):
            return
        
        try:
            sample_dir = self.config.get_sample_dir()
            picker = EnhancedSamplePicker(sample_dir)
            
            print("üîÑ –ü–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ —Å –∂–∞–Ω—Ä–æ–≤–æ–π –ø—Ä–∏–≤—è–∑–∫–æ–π...")
            picker.index = picker.build_enhanced_index()
            picker.save_index(picker.index)
            
            print("‚úÖ –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω!")
            print(f"üìä –ü—Ä–æ–∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–æ: {len(picker.index)} —Å—ç–º–ø–ª–æ–≤")
            
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –∂–∞–Ω—Ä–∞–º
            genre_stats = {}
            for sample in picker.index:
                for genre in sample.get("genres", []):
                    genre_stats[genre] = genre_stats.get(genre, 0) + 1
            
            if genre_stats:
                print(f"\nüé≠ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∂–∞–Ω—Ä–∞–º:")
                for genre, count in sorted(genre_stats.items(), key=lambda x: -x[1])[:10]:
                    print(f"  {genre}: {count} —Å—ç–º–ø–ª–æ–≤")
            
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞: {e}")
    
    def interactive_old_generation(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ä—ã–º –º–µ—Ç–æ–¥–æ–º (–¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)"""
        print("\nüéº –ì–ï–ù–ï–†–ê–¶–ò–Ø –¢–†–ï–ö–ê (—Å—Ç–∞—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º)")
        print("-" * 30)
        
        prompt = input("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: ").strip()
        if not prompt:
            print("‚ùå –ü—Ä–æ–º–ø—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
            return
        
        output_dir = input("–í—ã—Ö–æ–¥–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è (Enter –¥–ª—è 'output_legacy'): ").strip()
        if not output_dir:
            output_dir = "output_legacy"
        
        print("\n–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏:")
        professional_mix = input("–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–µ –º–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏–µ? (Y/n): ").lower() != 'n'
        export_stems = input("–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–µ–º—ã? (Y/n): ").lower() != 'n'
        
        try:
            sample_dir = self.config.get_sample_dir()
            
            print(f"\nüöÄ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–∫–∞ (legacy): '{prompt}'")
            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å —Å—Ç–∞—Ä—É—é —Ñ—É–Ω–∫—Ü–∏—é, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
            # final_path = self.full_track_generation(prompt, sample_dir, output_dir, professional_mix, export_stems)
            print("‚ö†Ô∏è –°—Ç–∞—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é —Ü–µ–ø–æ—á–∫—É (–ø—É–Ω–∫—Ç 1)")
                
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
            print(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
    
    def interactive_analyze_index(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞"""
        print("\nüìä –ê–ù–ê–õ–ò–ó –†–ê–°–®–ò–†–ï–ù–ù–û–ì–û –ò–ù–î–ï–ö–°–ê")
        print("-" * 40)
        
        sample_dir = self.config.get_sample_dir()
        picker = EnhancedSamplePicker(sample_dir)
        index = picker.index
        
        if not index:
            print("‚ùå –ò–Ω–¥–µ–∫—Å –ø—É—Å—Ç –∏–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω")
            return
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–µ–≥–æ–≤
        all_tags = []
        empty_tags = 0
        tempo_distribution = []
        duration_distribution = []
        genre_distribution = {}
        brightness_distribution = []
        
        for sample in index:
            tags = sample.get("tags", [])
            if not tags:
                empty_tags += 1
            else:
                all_tags.extend(tags)
            
            tempo_distribution.append(sample.get("tempo", 120))
            duration_distribution.append(sample.get("duration", 0))
            brightness_distribution.append(sample.get("brightness", 0))
            
            # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –∂–∞–Ω—Ä–∞–º
            for genre in sample.get("genres", []):
                genre_distribution[genre] = genre_distribution.get(genre, 0) + 1
        
        tag_counter = Counter(all_tags)
        
        print(f"üìà –û–ë–©–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê:")
        print(f"  –í—Å–µ–≥–æ —Å—ç–º–ø–ª–æ–≤: {len(index)}")
        print(f"  –ë–µ–∑ —Ç–µ–≥–æ–≤: {empty_tags} ({empty_tags/len(index)*100:.1f}%)")
        print(f"  –£–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ç–µ–≥–æ–≤: {len(tag_counter)}")
        print(f"  –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∂–∞–Ω—Ä–æ–≤: {len(genre_distribution)}")
        
        print(f"\nüè∑Ô∏è –¢–û–ü-10 –¢–ï–ì–û–í:")
        for tag, count in tag_counter.most_common(10):
            percentage = count / len(index) * 100
            print(f"  {tag}: {count} ({percentage:.1f}%)")
        
        print(f"\nüé≠ –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ü–û –ñ–ê–ù–†–ê–ú:")
        for genre, count in sorted(genre_distribution.items(), key=lambda x: -x[1])[:10]:
            percentage = count / len(index) * 100
            print(f"  {genre}: {count} ({percentage:.1f}%)")
        
        print(f"\nüéµ –†–ê–°–ü–†–ï–î–ï–õ–ï–ù–ò–ï –¢–ï–ú–ü–ê:")
        tempo_ranges = {
            "Very Slow (60-80)": len([t for t in tempo_distribution if 60 <= t < 80]),
            "Slow (80-100)": len([t for t in tempo_distribution if 80 <= t < 100]),
            "Medium (100-130)": len([t for t in tempo_distribution if 100 <= t < 130]),
            "Fast (130-160)": len([t for t in tempo_distribution if 130 <= t < 160]),
            "Very Fast (160+)": len([t for t in tempo_distribution if t >= 160])
        }
        
        for range_name, count in tempo_ranges.items():
            percentage = count / len(index) * 100
            print(f"  {range_name}: {count} ({percentage:.1f}%)")
        
        print(f"\n‚è±Ô∏è –î–õ–ò–¢–ï–õ–¨–ù–û–°–¢–¨ –°–≠–ú–ü–õ–û–í:")
        avg_duration = sum(duration_distribution) / len(duration_distribution)
        loops = len([d for d in duration_distribution if d > 8])
        oneshots = len([d for d in duration_distribution if d <= 8])
        print(f"  –°—Ä–µ–¥–Ω—è—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {avg_duration:.1f}—Å")
        print(f"  Loops (>8—Å): {loops} ({loops/len(index)*100:.1f}%)")
        print(f"  One-shots (‚â§8—Å): {oneshots} ({oneshots/len(index)*100:.1f}%)")
        
        # –ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ –∏–Ω–¥–µ–∫—Å–∞
        quality_samples = len([s for s in index if len(s.get("tags", [])) > 2 and s.get("key")])
        print(f"\n‚≠ê –ö–ê–ß–ï–°–¢–í–û –ò–ù–î–ï–ö–°–ê:")
        print(f"  –í—ã—Å–æ–∫–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ (>2 —Ç–µ–≥–æ–≤ + —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å): {quality_samples} ({quality_samples/len(index)*100:.1f}%)")
        
        if brightness_distribution:
            avg_brightness = sum([b for b in brightness_distribution if b > 0]) / len([b for b in brightness_distribution if b > 0])
            print(f"  –°—Ä–µ–¥–Ω—è—è —è—Ä–∫–æ—Å—Ç—å —Å–ø–µ–∫—Ç—Ä–∞: {avg_brightness:.3f}")
        
        input("\n–ù–∞–∂–º–∏—Ç–µ Enter –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è...")
    
    def interactive_settings(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
        print("\n‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò WAVEDREAM ENHANCED")
        print("-" * 40)
        
        print(f"üìÇ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å—ç–º–ø–ª–æ–≤: {self.config.get_sample_dir()}")
        print(f"üìÅ –í—ã—Ö–æ–¥–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {self.config.DEFAULT_OUTPUT_DIR}")
        print(f"‚è±Ô∏è –ú–∞–∫—Å. –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞–Ω–∞–ª–∏–∑–∞: {self.config.AUDIO_ANALYSIS['max_duration']} —Å–µ–∫")
        print(f"üéØ –ü–æ—Ä–æ–≥ —Å–∫–æ—Ä–∞: {self.config.SAMPLE_MATCHING['min_score_threshold']}")
        print(f"üéµ –¢–µ–º–ø–æ–≤–∞—è —Ç–æ–ª–µ—Ä–∞–Ω—Ç–Ω–æ—Å—Ç—å: {self.config.SAMPLE_MATCHING['tempo_tolerance']} BPM")
        
        print(f"\nüé≠ –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ –∂–∞–Ω—Ä—ã: {', '.join(GENRE_INFO.keys())}")
        print(f"üéõÔ∏è –°—Ç–∏–ª–∏ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {', '.join(set([info['mastering_style'] for info in GENRE_INFO.values()]))}")
        
        change = input("\n–ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏? (y/N): ")
        if change.lower().startswith('y'):
            print("üí° –†–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ config.py –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–∫")
            print("üí° –ñ–∞–Ω—Ä–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ GENRE_INFO –≤ —ç—Ç–æ–º —Ñ–∞–π–ª–µ")
    
    def run_single_generation(self, args):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–¥–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞ –∏–∑ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏"""
        try:
            sample_dir = args.sample_dir or self.config.get_sample_dir()
            
            if args.rebuild_index:
                logging.info("üîÑ –ü–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞...")
                picker = EnhancedSamplePicker(sample_dir)
                picker.index = picker.build_enhanced_index()
                picker.save_index(picker.index)
            
            logging.info(f"üöÄ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è: '{args.prompt}'")
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
            mastering_purpose = getattr(args, 'mastering_purpose', 'personal')
            
            if args.enhanced or args.full_chain:
                # –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ü–µ–ø–æ—á–∫–∞
                final_path, structure_data, used_samples, mastering_config = self.run_enhanced_full_chain(
                    args.prompt, sample_dir, args.output_dir, mastering_purpose, args.export_stems
                )
                
                if final_path:
                    print(f"\nüéâ –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
                    print(f"üìÅ –ú–∞—Å—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {final_path}")
                    if structure_data:
                        print(f"üé≠ –ñ–∞–Ω—Ä: {structure_data.get('detected_genre')}")
                        print(f"üéµ –¢–µ–º–ø: {structure_data.get('tempo')} BPM")
                        print(f"üéõÔ∏è –°—ç–º–ø–ª–æ–≤: {len(used_samples) if used_samples else 0}")
                        print(f"üéØ –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥: {mastering_purpose}")
                        if mastering_config:
                            print(f"üéöÔ∏è –•–∞—Ä–∞–∫—Ç–µ—Ä: {mastering_config.get('overall_character', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
                else:
                    print("‚ùå –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å")
            else:
                # –°—Ç–∞—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º (–∑–∞–≥–ª—É—à–∫–∞)
                print("‚ö†Ô∏è –°—Ç–∞—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ --enhanced –∏–ª–∏ --full-chain")
        
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
            if args.debug:
                traceback.print_exc()
    
    def run_batch_mode(self, batch_file):
        """–ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑ JSON —Ñ–∞–π–ª–∞"""
        try:
            with open(batch_file, 'r', encoding='utf-8') as f:
                batch_data = json.load(f)
            
            tasks = batch_data.get("tasks", [])
            default_settings = batch_data.get("default_settings", {})
            
            print(f"üì¶ –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞: {len(tasks)} –∑–∞–¥–∞—á")
            
            for i, task in enumerate(tasks, 1):
                print(f"\nüîÑ –ó–∞–¥–∞—á–∞ {i}/{len(tasks)}: {task.get('name', f'task_{i}')}") 
                
                # –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫
                task_settings = {**default_settings, **task}
                
                # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è
                prompt = task_settings.get("prompt")
                output_dir = os.path.join(
                    task_settings.get("output_dir", "batch_output"), 
                    f"task_{i}"
                )
                mastering_purpose = task_settings.get("mastering_purpose", "personal")
                
                if prompt:
                    if task_settings.get("enhanced", True):
                        final_path, _, _, _ = self.run_enhanced_full_chain(
                            prompt,
                            task_settings.get("sample_dir") or self.config.get_sample_dir(),
                            output_dir,
                            mastering_purpose,
                            task_settings.get("export_stems", True)
                        )
                    else:
                        print(f"  ‚ö†Ô∏è –°—Ç–∞—Ä—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –∑–∞–¥–∞—á–∏ {i}")
                        continue
                    
                    if final_path:
                        print(f"  ‚úÖ –ì–æ—Ç–æ–≤–æ: {final_path}")
                    else:
                        print(f"  ‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
            
            print(f"\nüéä –ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
            
        except Exception as e:
            logging.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞–∫–µ—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")


def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–º–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–∞–º–∏"""
    parser = argparse.ArgumentParser(
        description="üéµ WaveDream Enhanced Pro - Genre Detection & Smart Mastering Edition",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
–ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:

–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º:
  python main.py

–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ü–µ–ø–æ—á–∫–∞ (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è):
  python main.py --prompt "dark trap aggressive 160bpm" --enhanced --mastering-purpose freelance

–° –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–µ–π –∏ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–æ–º:
  python main.py --prompt "lofi chill study beats" --enhanced --mastering-purpose personal

–° –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ–º –∏–Ω–¥–µ–∫—Å–∞:
  python main.py --prompt "dnb liquid neurofunk 174bpm" --rebuild-index --enhanced

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–∏:
  python main.py --test-genre "phonk memphis cowbell drift"

–ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞:
  python main.py --batch enhanced_tasks.json

–ê–Ω–∞–ª–∏–∑ –±–∞–∑—ã —Å—ç–º–ø–ª–æ–≤:
  python main.py --analyze-index
        """
    )
    
    parser.add_argument("--prompt", type=str, help="–ü—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
    parser.add_argument("--sample-dir", type=str, help="–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å —Å—ç–º–ø–ª–∞–º–∏")
    parser.add_argument("--output-dir", type=str, default="output", help="–í—ã—Ö–æ–¥–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è")
    parser.add_argument("--rebuild-index", action="store_true", help="–ü–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å")
    parser.add_argument("--enhanced", action="store_true", help="–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è —Ü–µ–ø–æ—á–∫–∞ —Å –∂–∞–Ω—Ä–∞–º–∏ –∏ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–æ–º")
    parser.add_argument("--full-chain", action="store_true", help="–ê–ª–∏–∞—Å –¥–ª—è --enhanced")
    parser.add_argument("--export-stems", action="store_true", help="–≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö –≤–µ—Ä—Å–∏–π")
    parser.add_argument("--mastering-purpose", choices=["freelance", "professional", "personal", "family"], 
                        default="personal", help="–ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞")
    parser.add_argument("--test-genre", type=str, help="–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∂–∞–Ω—Ä–æ–≤–æ–π –¥–µ—Ç–µ–∫—Ü–∏–∏")
    parser.add_argument("--analyze-index", action="store_true", help="–ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞")
    parser.add_argument("--debug", action="store_true", help="–†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏")
    parser.add_argument("--batch", type=str, help="–ü–∞–∫–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑ JSON —Ñ–∞–π–ª–∞")
    
    args = parser.parse_args()
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    launcher = WaveDreamLauncher()
    
    # –†–∞–∑–ª–∏—á–Ω—ã–µ —Ä–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã
    if args.test_genre:
        print(f"\nüé≠ –¢–ï–°–¢ –ñ–ê–ù–†–û–í–û–ô –î–ï–¢–ï–ö–¶–ò–ò: '{args.test_genre}'")
        detected_genre, genre_info = detect_genre(args.test_genre)
        print(f"üé≠ –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∞–Ω—Ä: {detected_genre}")
        print(f"üéµ BPM –¥–∏–∞–ø–∞–∑–æ–Ω: {genre_info['bpm']}")
        print(f"üéõÔ∏è –°—Ç–∏–ª—å –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {genre_info['mastering_style']}")
        print(f"üéº –û—Å–Ω–æ–≤–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: {', '.join(genre_info['core_instruments'])}")
        print(f"üéπ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: {', '.join(genre_info['optional_instruments'])}")
    
    elif args.analyze_index:
        launcher.interactive_analyze_index()
    
    elif args.batch:
        launcher.run_batch_mode(args.batch)
    
    elif args.prompt:
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–∫–ª—é—á–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é —Ü–µ–ø–æ—á–∫—É, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ –∏–Ω–æ–µ
        if not hasattr(args, 'enhanced'):
            args.enhanced = True
        launcher.run_single_generation(args)
    
    else:
        # –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º
        launcher.run_interactive_mode()


def quick_start():
    """–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç —Å –∂–∞–Ω—Ä–æ–≤—ã–º–∏ –ø—Ä–∏–º–µ—Ä–∞–º–∏"""
    examples = [
        {
            "name": "Dark Trap Pro",
            "prompt": "dark aggressive trap 160bpm —Å –≤–æ–∫–∞–ª—å–Ω—ã–º–∏ —á–æ–ø–∞–º–∏ –∏ 808",
            "purpose": "freelance",
            "expected": "–ú—Ä–∞—á–Ω—ã–π trap –¥–ª—è –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–π –ø—Ä–æ–¥–∞–∂–∏"
        },
        {
            "name": "Melodic Lofi", 
            "prompt": "–º–µ–ª–æ–¥–∏—á–Ω—ã–π lofi study beats 75bpm —Å –≤–∏–Ω—Ç–∞–∂–Ω—ã–º–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏",
            "purpose": "personal",
            "expected": "–ú–µ–ª–æ–¥–∏—á–Ω—ã–π lofi –¥–ª—è –ª–∏—á–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è"
        },
        {
            "name": "Cinematic Epic",
            "prompt": "cinematic epic orchestral trailer music heroic 90bpm", 
            "purpose": "professional",
            "expected": "–≠–ø–∏—á–µ—Å–∫–∏–π —Å–∞—É–Ω–¥—Ç—Ä–µ–∫ –¥–ª—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è"
        },
        {
            "name": "Family House",
            "prompt": "house happy upbeat family dance 124bpm bright",
            "purpose": "family",
            "expected": "–Ø—Ä–∫–∏–π house –¥–ª—è —Å–µ–º–µ–π–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"
        }
    ]
    
    print("üöÄ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç WaveDream Enhanced Pro")
    print("–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∏–º–µ—Ä –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏:")
    
    for i, example in enumerate(examples, 1):
        print(f"{i}. {example['name']} - {example['expected']}")
        print(f"   –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ: {example['purpose']}")
    
    choice = input("\n–í—ã–±–æ—Ä (1-4): ").strip()
    
    if choice in ['1', '2', '3', '4']:
        idx = int(choice) - 1
        example = examples[idx]
        
        print(f"\nüéµ –ì–µ–Ω–µ—Ä–∏—Ä—É—é: {example['name']}")
        print(f"üìù –ü—Ä–æ–º–ø—Ç: {example['prompt']}")
        print(f"üéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ: {example['purpose']}")
        
        launcher = WaveDreamLauncher()
        output_dir = f"quick_start_{example['name'].lower().replace(' ', '_')}"
        
        final_path, structure_data, used_samples, mastering_config = launcher.run_enhanced_full_chain(
            example['prompt'],
            launcher.config.get_sample_dir(),
            output_dir,
            example['purpose'],
            export_stems=True
        )
        
        if final_path:
            print(f"\nüéâ –ì–æ—Ç–æ–≤–æ: {final_path}")
            if structure_data:
                detected_genre = structure_data.get('detected_genre', '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
                print(f"üé≠ –î–µ—Ç–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∂–∞–Ω—Ä: {detected_genre}")
                print(f"üéõÔ∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ —Å—ç–º–ø–ª–æ–≤: {len(used_samples) if used_samples else 0}")
        else:
            print("‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")


if __name__ == "__main__":
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è quick start
    if len(sys.argv) == 1:
        # –ï—Å–ª–∏ –Ω–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ - –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º
        launcher = WaveDreamLauncher()
        launcher.run_interactive_mode()
    elif len(sys.argv) == 2 and sys.argv[1] == "--quick-start":
        quick_start()
    else:
        main()

# config.py

# config.py - –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è WD

import os
from pathlib import Path

class Config:
    """–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–æ–µ–∫—Ç–∞"""
    
    # –ü—É—Ç–∏
    BASE_DIR = Path(__file__).parent
    DEFAULT_SAMPLE_DIR = r"D:\0\—à–∞–±–ª–æ–Ω—ã\Samples for AKAI"
    DEFAULT_OUTPUT_DIR = "wavedream_output"
    
    # –§–∞–π–ª—ã –∏–Ω–¥–µ–∫—Å–æ–≤
    ENHANCED_INDEX_FILE = "enhanced_sample_index.json"
    BACKUP_INDEX_FILE = "backup_sample_index.json"
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∞–Ω–∞–ª–∏–∑–∞ –∞—É–¥–∏–æ
    AUDIO_ANALYSIS = {
        "max_duration": 10,  # —Å–µ–∫—É–Ω–¥ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        "sample_rate": 22050,
        "hop_length": 512,
        "frame_size": 2048
    }
    
    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–¥–±–æ—Ä–∞ —Å—ç–º–ø–ª–æ–≤
    SAMPLE_MATCHING = {
        "min_score_threshold": 5,
        "tempo_tolerance": 30,  # BPM –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ
        "semantic_weight": 0.6,
        "tempo_weight": 0.2,
        "genre_weight": 0.1,
        "quality_weight": 0.1
    }
    
    # –ñ–∞–Ω—Ä–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    GENRE_SETTINGS = {
        "trap": {
            "bpm_range": (130, 170),
            "default_structure": [
                {"type": "intro", "duration": 8},
                {"type": "verse", "duration": 16},
                {"type": "hook", "duration": 16},
                {"type": "verse", "duration": 16},
                {"type": "hook", "duration": 16},
                {"type": "outro", "duration": 8}
            ],
            "core_instruments": ["kick", "snare", "hihat", "bass", "808"],
            "optional_instruments": ["lead", "vocal", "fx", "pad"]
        },
        "house": {
            "bpm_range": (118, 128),
            "default_structure": [
                {"type": "intro", "duration": 16},
                {"type": "build", "duration": 16},
                {"type": "drop", "duration": 32},
                {"type": "break", "duration": 16},
                {"type": "drop", "duration": 32},
                {"type": "outro", "duration": 16}
            ],
            "core_instruments": ["kick", "hihat", "bass", "clap"],
            "optional_instruments": ["piano", "vocal", "fx", "percussion"]
        },
        "techno": {
            "bpm_range": (120, 135),
            "default_structure": [
                {"type": "intro", "duration": 32},
                {"type": "build", "duration": 32},
                {"type": "peak", "duration": 64},
                {"type": "breakdown", "duration": 32},
                {"type": "outro", "duration": 32}
            ],
            "core_instruments": ["kick", "hihat", "bass", "fx"],
            "optional_instruments": ["lead", "pad", "percussion"]
        },
        "dnb": {
            "bpm_range": (160, 180),
            "default_structure": [
                {"type": "intro", "duration": 16},
                {"type": "buildup", "duration": 16},
                {"type": "drop", "duration": 32},
                {"type": "breakdown", "duration": 16},
                {"type": "drop", "duration": 32},
                {"type": "outro", "duration": 16}
            ],
            "core_instruments": ["kick", "snare", "bass", "hihat"],
            "optional_instruments": ["lead", "vocal", "fx", "percussion"]
        },
        "ambient": {
            "bpm_range": (60, 90),
            "default_structure": [
                {"type": "intro", "duration": 30},
                {"type": "development", "duration": 60},
                {"type": "climax", "duration": 45},
                {"type": "resolution", "duration": 45}
            ],
            "core_instruments": ["pad", "texture", "ambient"],
            "optional_instruments": ["piano", "fx", "vocal", "drone"]
        }
    }
    
    # –ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –∫–∞—Ä—Ç–∞ —Ç–µ–≥–æ–≤
    SEMANTIC_MAP = {
        # –£–¥–∞—Ä–Ω—ã–µ
        "kick": {
            "synonyms": ["kick", "bd", "bass_drum", "thump", "punch", "boom", "sub_kick"],
            "related": ["808", "sub", "low"],
            "genre_variants": {
                "trap": ["808_kick", "hard_kick", "punchy_kick"],
                "techno": ["techno_kick", "industrial_kick", "pounding_kick"],
                "house": ["house_kick", "four_on_floor", "groove_kick"]
            }
        },
        "snare": {
            "synonyms": ["snare", "snr", "crack", "snap", "backbeat"],
            "related": ["clap", "rim", "percussion"],
            "genre_variants": {
                "trap": ["trap_snare", "snappy_snare", "tight_snare"],
                "dnb": ["dnb_snare", "rolling_snare", "break_snare"],
                "house": ["house_clap", "deep_clap"]
            }
        },
        "hihat": {
            "synonyms": ["hat", "hh", "hi_hat", "closed_hat", "open_hat"],
            "related": ["cymbal", "shaker", "percussion"],
            "genre_variants": {
                "trap": ["trap_hat", "rolling_hat", "drill_hat"],
                "house": ["house_hat", "swing_hat"],
                "techno": ["tech_hat", "minimal_hat"]
            }
        },
        
        # –ë–∞—Å
        "bass": {
            "synonyms": ["bass", "sub", "low", "bassline", "low_end"],
            "related": ["808", "reese", "wobble", "growl"],
            "genre_variants": {
                "trap": ["808", "sub_bass", "sliding_bass"],
                "dnb": ["reese", "neurobass", "growl"],
                "house": ["house_bass", "deep_bass", "groove_bass"],
                "techno": ["acid_bass", "modular_bass"]
            }
        },
        
        # –ú–µ–ª–æ–¥–∏—á–µ—Å–∫–∏–µ
        "lead": {
            "synonyms": ["lead", "melody", "synth", "keys", "main"],
            "related": ["arp", "sequence", "hook"],
            "genre_variants": {
                "trap": ["trap_melody", "dark_lead", "minor_lead"],
                "house": ["piano", "organ", "electric_piano"],
                "techno": ["acid_lead", "analog_lead"],
                "ambient": ["soft_lead", "ethereal_lead"]
            }
        },
        
        "pad": {
            "synonyms": ["pad", "strings", "ambient", "texture", "atmosphere"],
            "related": ["drone", "wash", "background"],
            "genre_variants": {
                "ambient": ["ambient_pad", "space_pad", "ethereal_pad"],
                "house": ["warm_pad", "analog_pad"],
                "techno": ["dark_pad", "industrial_pad"]
            }
        },
        
        # –í–æ–∫–∞–ª
        "vocal": {
            "synonyms": ["vocal", "voice", "vox", "vocals", "sung"],
            "related": ["choir", "chant", "rap", "spoken"],
            "genre_variants": {
                "trap": ["rap", "autotune", "vocal_chop"],
                "house": ["soulful_vocal", "disco_vocal"],
                "ambient": ["ethereal_vocal", "choir", "chant"]
            }
        },
        
        # –≠—Ñ—Ñ–µ–∫—Ç—ã
        "fx": {
            "synonyms": ["fx", "effect", "sfx", "sound_effect"],
            "related": ["sweep", "riser", "impact", "whoosh", "transition"],
            "genre_variants": {
                "trap": ["trap_fx", "reverse_fx", "vinyl_stop"],
                "house": ["filter_sweep", "vocal_fx"],
                "techno": ["industrial_fx", "noise_fx"],
                "ambient": ["nature_fx", "space_fx"]
            }
        }
    }
    
    # –ú—É–¥—Ä–æ—Ç–µ—Ö—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è –ø–æ–¥–±–æ—Ä–∞
    MOOD_MODIFIERS = {
        "dark": {
            "tag_boost": ["minor", "dark", "evil", "horror", "deep"],
            "tempo_modifier": 0.95,  # –ß—É—Ç—å –º–µ–¥–ª–µ–Ω–Ω–µ–µ
            "volume_modifier": 1.1   # –ß—É—Ç—å –≥—Ä–æ–º—á–µ
        },
        "aggressive": {
            "tag_boost": ["hard", "aggressive", "punchy", "distorted"],
            "tempo_modifier": 1.05,  # –ß—É—Ç—å –±—ã—Å—Ç—Ä–µ–µ
            "volume_modifier": 1.2   # –ì—Ä–æ–º—á–µ
        },
        "melodic": {
            "tag_boost": ["melodic", "beautiful", "harmonic", "musical"],
            "tempo_modifier": 1.0,
            "volume_modifier": 0.9   # –ß—É—Ç—å —Ç–∏—à–µ
        },
        "chill": {
            "tag_boost": ["chill", "relaxed", "soft", "gentle"],
            "tempo_modifier": 0.9,   # –ú–µ–¥–ª–µ–Ω–Ω–µ–µ
            "volume_modifier": 0.8   # –¢–∏—à–µ
        }
    }
    
    # –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ –∏–º–µ–Ω–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–æ–≤
    FILENAME_PATTERNS = {
        "bpm_extraction": [
            r'(\d{2,3})\s*bpm',
            r'(\d{2,3})\s*beats',
            r'bpm[\s_-]*(\d{2,3})',
            r'tempo[\s_-]*(\d{2,3})',
            r'(\d{2,3})[\s_-]*beat'
        ],
        "key_extraction": [
            r'\b([a-g]#?)\s*m(?:inor)?(?:\s|$)',
            r'\b([a-g]#?)\s*maj(?:or)?(?:\s|$)',
            r'key[\s_-]*([a-g]#?)',
            r'in[\s_-]*([a-g]#?)',
            r'([a-g]#?)[\s_-]*(?:key|scale)'
        ],
        "instrument_patterns": {
            "kick": [r'\bkick\b', r'\bbd\b', r'\bbass[\s_-]*drum\b'],
            "snare": [r'\bsnare\b', r'\bsnr\b', r'\bcrack\b'],
            "hihat": [r'\bhat\b', r'\bhi[\s_-]*hat\b', r'\bhh\b'],
            "clap": [r'\bclap\b', r'\bhand[\s_-]*clap\b'],
            "bass": [r'\bbass\b', r'\bsub\b', r'\b808\b'],
            "vocal": [r'\bvocal\b', r'\bvox\b', r'\bvoice\b', r'\brap\b'],
            "fx": [r'\bfx\b', r'\beffect\b', r'\bsweep\b', r'\briser\b']
        }
    }
    
    # –ö–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
    QUALITY_FILTERS = {
        "min_duration": 0.5,      # –º–∏–Ω–∏–º—É–º 0.5 —Å–µ–∫
        "max_duration": 300,      # –º–∞–∫—Å–∏–º—É–º 5 –º–∏–Ω—É—Ç
        "min_sample_rate": 44100, # –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ
        "exclude_extensions": [".tmp", ".bak", ".old"],
        "exclude_folders": ["backup", "temp", "trash", "old"]
    }
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    PERFORMANCE = {
        "batch_size": 100,        # —Å–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –∑–∞ —Ä–∞–∑
        "max_workers": 4,         # –ø–æ—Ç–æ–∫–∏ –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
        "cache_size": 1000,       # —Ä–∞–∑–º–µ—Ä –∫—ç—à–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        "index_rebuild_threshold": 0.1  # –ø–æ—Ä–æ–≥ –¥–ª—è –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–¥–µ–∫—Å–∞
    }
    
    # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    LOGGING = {
        "level": "INFO",
        "format": "[%(levelname)s] %(asctime)s - %(message)s",
        "file": "wavedream.log",
        "max_size_mb": 50
    }

    @classmethod
    def get_sample_dir(cls):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞–±–æ—á–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å —Å—ç–º–ø–ª–∞–º–∏"""
        if os.path.exists(cls.DEFAULT_SAMPLE_DIR):
            return cls.DEFAULT_SAMPLE_DIR
        
        # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø—É—Ç–∏
        alternatives = [
            "samples",
            "audio_samples", 
            os.path.join(os.path.expanduser("~"), "Documents", "Samples"),
            "D:\\Samples",
            "C:\\Samples"
        ]
        
        for alt in alternatives:
            if os.path.exists(alt):
                return alt
        
        # –°–æ–∑–¥–∞—ë–º –¥–µ—Ñ–æ–ª—Ç–Ω—É—é
        os.makedirs("samples", exist_ok=True)
        return "samples"

    @classmethod
    def validate_config(cls):
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        errors = []
        
        sample_dir = cls.get_sample_dir()
        if not os.path.exists(sample_dir):
            errors.append(f"Sample directory not found: {sample_dir}")
        
        if cls.PERFORMANCE["max_workers"] < 1:
            errors.append("max_workers must be >= 1")
            
        if cls.AUDIO_ANALYSIS["max_duration"] < 1:
            errors.append("max_duration must be >= 1")
            
        return errors

# smart_mixer.py

import os
import logging
from pydub import AudioSegment
from sample_picker import pick_samples
from SIG import load_index
from musicgen_wrapper import generate_music
import soundfile as sf
import uuid

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')

def smart_mix(json_data, sample_dir, output_dir="output", ignore_bpm=False):
    os.makedirs(output_dir, exist_ok=True)
    tempo = json_data.get("tempo", 120)
    structure = json_data.get("structure", [])
    tracks = json_data.get("tracks", [])

    total_duration_sec = sum([s["duration"] for s in structure])
    total_duration_ms = int(total_duration_sec * 1000)

    final_mix = AudioSegment.silent(duration=total_duration_ms)

    for track in tracks:
        name = track.get("name", "unknown")
        tags = track.get("sample_tags", [])
        volume = track.get("volume", -6)

        starts_at_beats = track.get("starts_at", 0)
        ends_at_beats = track.get("ends_at", None)

        beat_time = 60.0 / tempo
        starts_at_ms = int(starts_at_beats * beat_time * 1000)
        ends_at_ms = int(ends_at_beats * beat_time * 1000) if ends_at_beats else total_duration_ms

        duration_ms = ends_at_ms - starts_at_ms

        picked = pick_samples(tags, genre_hint=None, energy=0.5, tempo=tempo, sample_dir=sample_dir)

        if not picked:
            logging.warning(f"üß´ Fallback: –≥–µ–Ω–µ—Ä–∏–º MusicGen stem –¥–ª—è '{name}' (—Ç–µ–≥–∏: {tags})")
            prompt = f"instrumental stem for {name} with tags {', '.join(tags)}"
            gen_duration = (ends_at_beats - starts_at_beats) if ends_at_beats else 8
            waveform, sr = generate_music(prompt, duration=gen_duration)
            mgen_path = os.path.join(output_dir, f"musicgen_{name}.wav")
            sf.write(mgen_path, waveform.squeeze().numpy(), sr)
            seg = AudioSegment.from_file(mgen_path)
        else:
            sample_path = picked[0]["path"]
            seg = AudioSegment.from_file(sample_path)

        # –ü–æ–¥–≥–æ–Ω–∫–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
        if len(seg) > duration_ms:
            seg = seg[:duration_ms]
        elif len(seg) < duration_ms:
            pad = AudioSegment.silent(duration=duration_ms - len(seg))
            seg += pad

        seg = seg.apply_gain(volume)
        final_mix = final_mix.overlay(seg, position=starts_at_ms)

        track_path = os.path.join(output_dir, f"{name}.wav")
        seg.export(track_path, format="wav")
        logging.info(f"üîä [{name}] {starts_at_ms}ms ‚Üí {ends_at_ms}ms  ({tags})")

    final_path = os.path.join(output_dir, "final_mix.wav")
    final_mix.export(final_path, format="wav")
    logging.info(f"üéõ –§–∏–Ω–∞–ª –º–∏–∫—Å: {final_path}")
    return final_mix

# self_check.py

import os
import logging
from pydub import AudioSegment
import numpy as np
import librosa


def check_rms(audio: AudioSegment) -> float:
    samples = np.array(audio.get_array_of_samples())
    return np.sqrt(np.mean(samples**2))


def is_too_silent(audio: AudioSegment, threshold_db: float = -40.0) -> bool:
    rms_db = audio.dBFS
    logging.info(f"üîç RMS dBFS: {rms_db:.2f}")
    return rms_db < threshold_db


def has_enough_duration(audio: AudioSegment, min_duration_sec: float = 10.0) -> bool:
    return len(audio) >= min_duration_sec * 1000


def is_mostly_silence(path, threshold_db=-45.0, max_silent_ratio=0.5) -> bool:
    try:
        y, sr = librosa.load(path, sr=None)
        S = librosa.feature.rms(y=y)[0]
        silence = S < librosa.db_to_amplitude(threshold_db)
        silent_ratio = np.mean(silence)
        logging.info(f"üîç Silent frames: {silent_ratio * 100:.1f}%")
        return silent_ratio > max_silent_ratio
    except Exception as e:
        logging.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ç–∏—à–∏–Ω—ã: {e}")
        return False


def verify_mix(path: str) -> dict:
    logging.info(f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –º–∏–∫—Å–∞: {path}")

    if not os.path.exists(path):
        return {"ok": False, "reason": "no_file"}

    try:
        audio = AudioSegment.from_file(path)
    except Exception as e:
        logging.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {e}")
        return {"ok": False, "reason": "load_fail"}

    if not has_enough_duration(audio):
        return {"ok": False, "reason": "too_short"}

    if is_too_silent(audio):
        return {"ok": False, "reason": "too_silent"}

    if is_mostly_silence(path):
        return {"ok": False, "reason": "mostly_silent"}

    return {"ok": True}

# musicgen_wrapper.py

import torch
from audiocraft.models import musicgen
import torchaudio
from audiocraft.models.musicgen import MusicGen

model = None

def load_musicgen_model(path="D:/2027/audiocraft/audiocraft/models/facebook/musicgen-medium"):
    global model
    if model is None:
        model = musicgen.MusicGen.get_pretrained(path)
    return model

def generate_music(prompt: str, duration: int = 30):
    model = load_musicgen_model()
    model.set_generation_params(duration=duration)
    output = model.generate([prompt])
    return output[0].cpu(), model.sample_rate
