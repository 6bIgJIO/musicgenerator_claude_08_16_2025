import re
import os
import json
import logging
import numpy as np
import asyncio
import pickle
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
import time

# ML –∏ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑
try:
    from sentence_transformers import SentenceTransformer
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.cluster import KMeans
    from sklearn.decomposition import PCA
    SEMANTIC_AVAILABLE = True
except ImportError:
    SEMANTIC_AVAILABLE = False
    logging.warning("Semantic analysis libraries not available")

# –ê—É–¥–∏–æ –∞–Ω–∞–ª–∏–∑
import librosa
import soundfile as sf
from pydub import AudioSegment, effects
from pydub.effects import compress_dynamic_range, normalize

# –£–±–∏—Ä–∞–µ–º –∏–º–ø–æ—Ä—Ç config —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏—Ö –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
# from config import config

# ============================================================================
# –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –î–ê–¢–ê–ö–õ–ê–°–°–´
# ============================================================================

@dataclass
class SampleMetadata:
    """–ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å—ç–º–ø–ª–∞ - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –≤–µ—Ä—Å–∏—è"""
    # –û—Å–Ω–æ–≤–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
    path: str
    filename: str
    duration: float
    tempo: int  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bpm –≤–º–µ—Å—Ç–æ bmp
    key: Optional[str]
    tags: List[str]
    genres: List[str]
    instrument_role: Optional[str]
    
    # –ê—É–¥–∏–æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ (–≤—Å–µ —Å –¥–µ—Ñ–æ–ª—Ç–∞–º–∏)
    spectral_centroid: float = 0.0
    spectral_rolloff: float = 0.0
    zero_crossing_rate: float = 0.0
    brightness: float = 0.0
    quality_score: float = 0.6
    energy_level: float = 0.5
    rhythmic_complexity: float = 0.0
    
    # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
    relative_path: Optional[str] = None
    category: Optional[str] = None
    semantic_embedding: Optional[np.ndarray] = None
    semantic_cluster: Optional[int] = None

# ============================================================================
# –ì–õ–ê–í–ù–´–ô –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ö–õ–ê–°–° –°–ï–ú–ê–ù–¢–ò–ß–ï–°–ö–û–ì–û –ü–û–ò–°–ö–ê
# ============================================================================

class FixedSemanticSampleEngine:
    """
    –ü–û–õ–ù–û–°–¢–¨–Æ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –¥–≤–∏–∂–æ–∫ –¥–ª—è –ø–æ–¥–±–æ—Ä–∞ —Å—ç–º–ø–ª–æ–≤
    
    ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
    - –†–∞–±–æ—Ç–∞–µ—Ç –¢–û–õ–¨–ö–û —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ —Å—ç–º–ø–ª–∞–º–∏ –∏–∑ JSON –∏–Ω–¥–µ–∫—Å–∞
    - –£–±—Ä–∞–Ω–∞ –≤—Å—è —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è 
    - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ bmp->bpm –æ–ø–µ—á–∞—Ç–∫–∏
    - –ß–µ—Å—Ç–Ω—ã–π —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫
    - –ù–∏–∫–∞–∫–∏—Ö fallback'–æ–≤ –Ω–∞ —Ñ–µ–π–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    """
    
    def __init__(self, sample_dir: str = None):
        # –ë–∞–∑–æ–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        self.sample_dir = sample_dir or "./samples"
        self.logger = logging.getLogger(__name__)
        self.samples_index: List[SampleMetadata] = []
        self.semantic_model = None
        self.embeddings_cache = {}
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –º–æ–¥–µ–ª–∏
        if SEMANTIC_AVAILABLE:
            try:
                self.semantic_model = SentenceTransformer('all-MiniLM-L6-v2')
                self.logger.info("‚úÖ –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞: {e}")
        
        # –ì–õ–ê–í–ù–û–ï: –ó–∞–≥—Ä—É–∂–∞–µ–º –†–ï–ê–õ–¨–ù–´–ô –∏–Ω–¥–µ–∫—Å
        self.load_real_sample_index()
        
        self.logger.info(f"üéØ SemanticSampleEngine –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω: {len(self.samples_index)} –†–ï–ê–õ–¨–ù–´–• —Å—ç–º–ø–ª–æ–≤")
    
    def load_real_sample_index(self):
        """
        –ó–∞–≥—Ä—É–∑–∫–∞ –†–ï–ê–õ–¨–ù–û–ì–û –∏–Ω–¥–µ–∫—Å–∞ —Å—ç–º–ø–ª–æ–≤ –∏–∑ —Ç–≤–æ–µ–≥–æ JSON —Ñ–∞–π–ª–∞
        –ù–ï–¢ –ù–ò–ö–ê–ö–ò–• –°–ò–ù–¢–ï–¢–ò–ß–ï–°–ö–ò–• FALLBACK'–û–í!
        """
        self.logger.info("üìÇ –ó–∞–≥—Ä—É–∂–∞–µ–º –†–ï–ê–õ–¨–ù–´–ô –∏–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤")
        
        # –í–æ–∑–º–æ–∂–Ω—ã–µ –ø—É—Ç–∏ –∫ —Ç–≤–æ–µ–º—É –∏–Ω–¥–µ–∫—Å—É
        possible_paths = [
            "sample_index ‚Äî –∫–æ–ø–∏—è2025.08.json",  # –¢–≤–æ–π –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª
            "sample_index.json",
            "enhanced_sample_index.json", 
            os.path.join(self.sample_dir, "sample_index.json"),
            os.path.join(self.sample_dir, "sample_index ‚Äî –∫–æ–ø–∏—è2025.08.json"),
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
            "wavedream_sample_index.json",
            os.path.join(".", "sample_index ‚Äî –∫–æ–ø–∏—è2025.08.json")
        ]
        
        loaded = False
        
        for index_path in possible_paths:
            if os.path.exists(index_path):
                try:
                    self.logger.info(f"  üìã –ù–∞–π–¥–µ–Ω –∏–Ω–¥–µ–∫—Å: {index_path}")
                    
                    with open(index_path, 'r', encoding='utf-8') as f:
                        raw_data = json.load(f)
                    
                    if isinstance(raw_data, list) and len(raw_data) > 0:
                        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç
                        converted_count = self._convert_real_index_to_internal(raw_data)
                        
                        if converted_count > 0:
                            self.logger.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {converted_count} –†–ï–ê–õ–¨–ù–´–• —Å—ç–º–ø–ª–æ–≤ –∏–∑ {index_path}")
                            loaded = True
                            break
                        else:
                            self.logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—ç–º–ø–ª—ã –∏–∑ {index_path}")
                    else:
                        self.logger.warning(f"‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–Ω–¥–µ–∫—Å–∞ {index_path}")
                
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ {index_path}: {e}")
                    continue
        
        if not loaded:
            self.logger.error("‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –†–ï–ê–õ–¨–ù–´–ô –∏–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤ –ù–ï –ù–ê–ô–î–ï–ù!")
            self.logger.error("‚ùå –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–∞ 'sample_index ‚Äî –∫–æ–ø–∏—è2025.08.json' –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–æ–µ–∫—Ç–∞")
            self.logger.error("‚ùå –ë–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Ä–∞–±–æ—Ç–∞—Ç—å –ù–ï –ë–£–î–ï–¢!")
            self.samples_index = []
    
    def _convert_real_index_to_internal(self, raw_data: List[Dict]) -> int:
        """
        –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Ç–≤–æ–µ–≥–æ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –≤ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç
        """
        self.samples_index = []
        converted_count = 0
        
        for item in raw_data:
            try:
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –≤—Å–µ—Ö –ø–æ–ª–µ–π
                metadata = SampleMetadata(
                    path=item.get("path", ""),
                    filename=item.get("filename", "unknown.wav"),
                    duration=float(item.get("duration", 0.0)),
                    tempo=int(item.get("tempo", 120)),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –ø–æ–ª–µ
                    key=item.get("key"),
                    tags=item.get("tags", []),
                    genres=item.get("genres", []),
                    instrument_role=item.get("instrument_role"),
                    spectral_centroid=float(item.get("spectral_centroid", 0.0)),
                    spectral_rolloff=float(item.get("spectral_rolloff", 0.0)),
                    zero_crossing_rate=float(item.get("zero_crossing_rate", 0.0)),
                    brightness=float(item.get("brightness", 0.0)),
                    quality_score=float(item.get("quality_score", 0.6)),
                    energy_level=float(item.get("energy_level", 0.5)),
                    rhythmic_complexity=float(item.get("rhythmic_complexity", 0.0)),
                    relative_path=item.get("relative_path"),
                    category=item.get("category", "oneshot" if item.get("duration", 0) < 8 else "loop")
                )
                
                # –í–∞–ª–∏–¥–∞—Ü–∏—è: –ø—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ñ–∞–π–ª —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                if os.path.exists(metadata.path):
                    self.samples_index.append(metadata)
                    converted_count += 1
                else:
                    self.logger.debug(f"  ‚ö†Ô∏è –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º: {metadata.path}")
                    
            except Exception as e:
                self.logger.debug(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —Å—ç–º–ø–ª–∞: {e}")
                continue
        
        self.logger.info(f"üéØ –°–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ {converted_count} –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –†–ï–ê–õ–¨–ù–´–• —Å—ç–º–ø–ª–æ–≤")
        return converted_count
    
    async def find_samples(
        self,
        tags: List[str],
        instruments: Optional[List[str]] = None,
        genre: Optional[str] = None,
        bpm: Optional[int] = None,  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bpm –≤–º–µ—Å—Ç–æ bmp
        energy: float = 0.5,
        max_results: int = 10,
        min_quality: float = 0.1  # –ü–æ–Ω–∏–∂–µ–Ω –ø–æ—Ä–æ–≥ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ö–æ—Ç—å —á–µ–≥–æ-—Ç–æ
    ) -> List[Dict]:
        """
        –ß–ï–°–¢–ù–´–ô —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –ø–æ –†–ï–ê–õ–¨–ù–û–ô –±–∞–∑–µ —Å—ç–º–ø–ª–æ–≤
        
        Args:
            tags: –°–ø–∏—Å–æ–∫ —Ç–µ–≥–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞
            instruments: –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã  
            genre: –¶–µ–ª–µ–≤–æ–π –∂–∞–Ω—Ä
            bpm: –¶–µ–ª–µ–≤–æ–π BPM (–ò–°–ü–†–ê–í–õ–ï–ù–û)
            energy: –£—Ä–æ–≤–µ–Ω—å —ç–Ω–µ—Ä–≥–∏–∏ (0-1)
            max_results: –ú–∞–∫—Å–∏–º—É–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            min_quality: –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–∞—á–µ—Å—Ç–≤–æ (–ø–æ–Ω–∏–∂–µ–Ω–æ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ö–æ—Ç—å —á–µ–≥–æ-—Ç–æ)
        """
        start_time = time.time()
        
        self.logger.info(f"üîç –†–ï–ê–õ–¨–ù–´–ô –ø–æ–∏—Å–∫ —Å—ç–º–ø–ª–æ–≤: —Ç–µ–≥–∏={tags}, –∂–∞–Ω—Ä={genre}, BPM={bpm}")
        
        # –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: –µ—Å—Ç—å –ª–∏ –≤–æ–æ–±—â–µ —Å—ç–º–ø–ª—ã?
        if not self.samples_index:
            self.logger.error("‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –ò–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤ –ø—É—Å—Ç!")
            self.logger.error("‚ùå –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω –±–µ–∑ —Ä–µ–∞–ª—å–Ω—ã—Ö —Å—ç–º–ø–ª–æ–≤!")
            return []
        
        # –ò—â–µ–º –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ —Å—Ä–µ–¥–∏ –†–ï–ê–õ–¨–ù–´–• —Å—ç–º–ø–ª–æ–≤
        candidates = []
        
        for sample in self.samples_index:
            score = self._calculate_semantic_score(sample, tags, instruments, genre, bpm, energy)
            
            # –û—á–µ–Ω—å –Ω–∏–∑–∫–∏–π –ø–æ—Ä–æ–≥ —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ —Ö–æ—Ç—å —á—Ç–æ-—Ç–æ
            if score > 0.01:  
                candidates.append({
                    "metadata": sample,
                    "score": score,
                    "path": sample.path,
                    "filename": sample.filename,
                    "instrument_role": sample.instrument_role,
                    "tags": sample.tags,
                    "tempo": sample.tempo,  # –ò–°–ü–†–ê–í–õ–ï–ù–û: tempo –≤–º–µ—Å—Ç–æ bmp
                    "quality_score": sample.quality_score,
                    "energy_level": sample.energy_level,
                    "spectral_centroid": sample.spectral_centroid,
                    "spectral_rolloff": sample.spectral_rolloff,
                    "zero_crossing_rate": sample.zero_crossing_rate,
                    "brightness": sample.brightness,
                    "rhythmic_complexity": sample.rhythmic_complexity,
                    "duration": sample.duration,
                    "key": sample.key,
                    "genres": sample.genres,
                    "category": sample.category
                })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–∫–æ—Ä—É (–ª—É—á—à–∏–µ —Å–Ω–∞—á–∞–ª–∞)
        candidates.sort(key=lambda x: x["score"], reverse=True)
        
        # –î–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø–æ–≤—Ç–æ—Ä–æ–≤
        diversified_results = self._diversify_search_results(candidates, max_results)
        
        search_time = time.time() - start_time
        
        if diversified_results:
            best_score = diversified_results[0]["score"]
            self.logger.info(f"  ‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(diversified_results)} –†–ï–ê–õ–¨–ù–´–• —Å—ç–º–ø–ª–æ–≤ –∑–∞ {search_time:.2f}—Å")
            self.logger.info(f"  üéØ –õ—É—á—à–∏–π —Å–∫–æ—Ä: {best_score:.3f} ({diversified_results[0]['filename']})")
        else:
            self.logger.warning(f"  ‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å—ç–º–ø–ª–æ–≤ –∑–∞ {search_time:.2f}—Å")
            self.logger.warning(f"  üìä –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –∫—Ä–∏—Ç–µ—Ä–∏–∏ –ø–æ–∏—Å–∫–∞")
        
        return diversified_results[:max_results]
    
    def _calculate_semantic_score(
        self, 
        sample: SampleMetadata, 
        tags: List[str], 
        instruments: Optional[List[str]], 
        genre: Optional[str],
        bpm: Optional[int],  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bpm –≤–º–µ—Å—Ç–æ bmp
        energy: float
    ) -> float:
        """
        –†–∞—Å—á—ë—Ç —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–∫–æ—Ä–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è –†–ï–ê–õ–¨–ù–û–ì–û —Å—ç–º–ø–ª–∞ –∑–∞–ø—Ä–æ—Å—É
        """
        total_score = 0.0
        
        # === 1. –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –¢–ï–ì–û–í (35% –æ—Ç –æ–±—â–µ–≥–æ —Å–∫–æ—Ä–∞) ===
        if tags:
            tag_score = 0.0
            sample_tags_lower = [tag.lower() for tag in sample.tags]
            filename_lower = sample.filename.lower()
            
            for search_tag in tags:
                search_tag_lower = search_tag.lower()
                
                # –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –≤ —Ç–µ–≥–∞—Ö (–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–ª)
                if search_tag_lower in sample_tags_lower:
                    tag_score += 1.0
                    continue
                
                # –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –≤ —Ç–µ–≥–∞—Ö
                for sample_tag in sample_tags_lower:
                    if search_tag_lower in sample_tag or sample_tag in search_tag_lower:
                        tag_score += 0.7
                        break
                else:
                    # –ü–æ–∏—Å–∫ –≤ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ (–º–µ–Ω—å—à–∏–π –±–∞–ª–ª)
                    if search_tag_lower in filename_lower:
                        tag_score += 0.3
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∏—Å–∫–æ–º—ã—Ö —Ç–µ–≥–æ–≤
            if len(tags) > 0:
                tag_score = min(1.0, tag_score / len(tags))
                total_score += tag_score * 0.35
        
        # === 2. –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–û–í (25% –æ—Ç –æ–±—â–µ–≥–æ —Å–∫–æ—Ä–∞) ===
        if instruments and sample.instrument_role:
            instrument_score = 0.0
            sample_role_lower = sample.instrument_role.lower()
            
            for search_instrument in instruments:
                search_instrument_lower = search_instrument.lower()
                
                # –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                if search_instrument_lower == sample_role_lower:
                    instrument_score = 1.0
                    break
                
                # –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                if (search_instrument_lower in sample_role_lower or 
                    sample_role_lower in search_instrument_lower):
                    instrument_score = max(instrument_score, 0.7)
                
                # –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–µ —Å–∏–Ω–æ–Ω–∏–º—ã
                synonyms = {
                    'kick': ['bd', 'bassdrum', 'drum'],
                    'snare': ['sd', 'crack', 'snap'],
                    'hihat': ['hh', 'hat', 'cymbal'],
                    'bass': ['sub', '808', 'low'],
                    'lead': ['melody', 'synth', 'main'],
                    'pad': ['chord', 'strings', 'atmosphere']
                }
                
                if search_instrument_lower in synonyms:
                    for synonym in synonyms[search_instrument_lower]:
                        if synonym in sample_role_lower:
                            instrument_score = max(instrument_score, 0.5)
                            break
            
            total_score += instrument_score * 0.25
        
        # === 3. –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –ñ–ê–ù–†–ê (20% –æ—Ç –æ–±—â–µ–≥–æ —Å–∫–æ—Ä–∞) ===
        if genre and sample.genres:
            genre_score = 0.0
            genre_lower = genre.lower()
            
            for sample_genre in sample.genres:
                sample_genre_lower = sample_genre.lower()
                
                # –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                if genre_lower == sample_genre_lower:
                    genre_score = 1.0
                    break
                
                # –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
                if (genre_lower in sample_genre_lower or 
                    sample_genre_lower in genre_lower):
                    genre_score = max(genre_score, 0.6)
            
            # –ï—Å–ª–∏ –∂–∞–Ω—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ, –∏—â–µ–º –≤ —Ç–µ–≥–∞—Ö –∏ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
            if genre_score == 0.0:
                filename_and_tags = (sample.filename.lower() + " " + 
                                   " ".join(sample.tags).lower())
                if genre_lower in filename_and_tags:
                    genre_score = 0.3
            
            total_score += genre_score * 0.20
        
        # === 4. –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï BPM/–¢–ï–ú–ü–ê (10% –æ—Ç –æ–±—â–µ–≥–æ —Å–∫–æ—Ä–∞) ===
        if bpm and sample.tempo:  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bpm –≤–º–µ—Å—Ç–æ bmp
            tempo_diff = abs(sample.tempo - bpm)
            
            if tempo_diff == 0:
                tempo_score = 1.0
            elif tempo_diff <= 3:
                tempo_score = 0.9
            elif tempo_diff <= 10:
                tempo_score = 0.7
            elif tempo_diff <= 20:
                tempo_score = 0.4
            elif tempo_diff <= 40:
                tempo_score = 0.2
            else:
                tempo_score = 0.0
            
            total_score += tempo_score * 0.10
        
        # === 5. –°–û–û–¢–í–ï–¢–°–¢–í–ò–ï –≠–ù–ï–†–ì–ò–ò (5% –æ—Ç –æ–±—â–µ–≥–æ —Å–∫–æ—Ä–∞) ===
        energy_diff = abs(sample.energy_level - energy)
        energy_score = max(0.0, 1.0 - energy_diff)
        total_score += energy_score * 0.05
        
        # === 6. –ë–û–ù–£–°–´ –ó–ê –ö–ê–ß–ï–°–¢–í–û –ò –•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ò (5% –æ—Ç –æ–±—â–µ–≥–æ —Å–∫–æ—Ä–∞) ===
        # –ë–æ–Ω—É—Å –∑–∞ –∫–∞—á–µ—Å—Ç–≤–æ —Å—ç–º–ø–ª–∞
        quality_bonus = sample.quality_score * 0.03
        
        # –ë–æ–Ω—É—Å –∑–∞ –Ω–∞–ª–∏—á–∏–µ —Å–ø–µ–∫—Ç—Ä–∞–ª—å–Ω—ã—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
        spectral_bonus = 0.01 if sample.spectral_centroid > 0 else 0.0
        
        # –ë–æ–Ω—É—Å –∑–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (–ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —Å—Ä–µ–¥–Ω–∏–µ –¥–ª–∏–Ω—ã)
        duration_bonus = 0.0
        if 1.0 <= sample.duration <= 30.0:  # –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞
            duration_bonus = 0.01
        
        total_score += quality_bonus + spectral_bonus + duration_bonus
        
        # –§–∏–Ω–∞–ª—å–Ω–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
        return min(1.0, max(0.0, total_score))
    
    def _diversify_search_results(self, candidates: List[Dict], max_results: int) -> List[Dict]:
        """
        –î–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞ –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –ø–æ–≤—Ç–æ—Ä–æ–≤ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        """
        if len(candidates) <= max_results:
            return candidates
        
        diversified = []
        used_instruments = set()
        used_files = set()
        
        # –ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ö–æ–¥: –±–µ—Ä—ë–º –ª—É—á—à–∏–µ —Å—ç–º–ø–ª—ã —Ä–∞–∑–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
        for candidate in candidates:
            if len(diversified) >= max_results:
                break
            
            instrument = candidate.get("instrument_role", "unknown")
            filename = candidate.get("filename", "")
            
            # –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —Ä–∞–∑–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∏ –∏–∑–±–µ–≥–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ —Ñ–∞–π–ª–æ–≤
            if (instrument not in used_instruments or len(used_instruments) < 3) and filename not in used_files:
                diversified.append(candidate)
                used_instruments.add(instrument)
                used_files.add(filename)
        
        # –í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ö–æ–¥: –¥–æ–±–∞–≤–ª—è–µ–º –ª—É—á—à–∏–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è (–±–µ–∑ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ —Ñ–∞–π–ª–æ–≤)
        for candidate in candidates:
            if len(diversified) >= max_results:
                break
            
            filename = candidate.get("filename", "")
            if candidate not in diversified and filename not in used_files:
                diversified.append(candidate)
                used_files.add(filename)
        
        return diversified[:max_results]
    
    def get_samples_statistics(self) -> Dict[str, Any]:
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–º –†–ï–ê–õ–¨–ù–´–ú —Å—ç–º–ø–ª–∞–º
        """
        if not self.samples_index:
            return {
                "total_samples": 0,
                "error": "–ò–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤ –ø—É—Å—Ç"
            }
        
        # –ë–∞–∑–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        stats = {
            "total_samples": len(self.samples_index),
            "total_duration_minutes": sum(s.duration for s in self.samples_index) / 60,
            "avg_quality": sum(s.quality_score for s in self.samples_index) / len(self.samples_index),
            "avg_energy": sum(s.energy_level for s in self.samples_index) / len(self.samples_index)
        }
        
        # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º
        instrument_dist = {}
        for sample in self.samples_index:
            instrument = sample.instrument_role or "unknown"
            instrument_dist[instrument] = instrument_dist.get(instrument, 0) + 1
        stats["instrument_distribution"] = dict(sorted(instrument_dist.items(), 
                                                      key=lambda x: x[1], reverse=True))
        
        # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∂–∞–Ω—Ä–∞–º
        genre_dist = {}
        for sample in self.samples_index:
            for genre in sample.genres:
                genre_dist[genre] = genre_dist.get(genre, 0) + 1
        stats["genre_distribution"] = dict(sorted(genre_dist.items(), 
                                                 key=lambda x: x[1], reverse=True))
        
        # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ —Ç–µ–º–ø—É
        tempo_ranges = {"slow": 0, "medium": 0, "fast": 0, "very_fast": 0}
        for sample in self.samples_index:
            if sample.tempo < 90:
                tempo_ranges["slow"] += 1
            elif sample.tempo < 130:
                tempo_ranges["medium"] += 1
            elif sample.tempo < 170:
                tempo_ranges["fast"] += 1
            else:
                tempo_ranges["very_fast"] += 1
        stats["tempo_distribution"] = tempo_ranges
        
        # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ —ç–Ω–µ—Ä–≥–∏–∏
        energy_ranges = {"low": 0, "medium": 0, "high": 0}
        for sample in self.samples_index:
            if sample.energy_level < 0.4:
                energy_ranges["low"] += 1
            elif sample.energy_level < 0.7:
                energy_ranges["medium"] += 1
            else:
                energy_ranges["high"] += 1
        stats["energy_distribution"] = energy_ranges
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –º–æ–¥–µ–ª–∏
        stats["semantic_model_available"] = self.semantic_model is not None
        stats["embeddings_cached"] = len(self.embeddings_cache)
        
        return stats
    
    def find_similar_samples(self, reference_sample_path: str, max_results: int = 5) -> List[Dict]:
        """
        –ü–æ–∏—Å–∫ —Å—ç–º–ø–ª–æ–≤, –ø–æ—Ö–æ–∂–∏—Ö –Ω–∞ –¥–∞–Ω–Ω—ã–π –†–ï–ê–õ–¨–ù–´–ô —Å—ç–º–ø–ª
        """
        if not self.samples_index:
            self.logger.error("‚ùå –ù–µ—Ç —Å—ç–º–ø–ª–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ—Ö–æ–∂–∏—Ö")
            return []
        
        # –ù–∞–π–¥—ë–º —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–Ω—ã–π —Å—ç–º–ø–ª –≤ –∏–Ω–¥–µ–∫—Å–µ
        reference_sample = None
        for sample in self.samples_index:
            if sample.path == reference_sample_path or sample.filename in reference_sample_path:
                reference_sample = sample
                break
        
        if not reference_sample:
            self.logger.error(f"‚ùå –†–µ—Ñ–µ—Ä–µ–Ω—Å–Ω—ã–π —Å—ç–º–ø–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {reference_sample_path}")
            return []
        
        self.logger.info(f"üîç –ü–æ–∏—Å–∫ –ø–æ—Ö–æ–∂–∏—Ö –Ω–∞: {reference_sample.filename}")
        
        # –ò—â–µ–º –ø–æ—Ö–æ–∂–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫
        similar_candidates = []
        
        for sample in self.samples_index:
            if sample.path == reference_sample.path:
                continue  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∞–º —Ä–µ—Ñ–µ—Ä–µ–Ω—Å–Ω—ã–π —Å—ç–º–ø–ª
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ—Ö–æ–∂–µ—Å—Ç—å
            similarity_score = self._calculate_similarity_score(reference_sample, sample)
            
            if similarity_score > 0.3:  # –ü–æ—Ä–æ–≥ –ø–æ—Ö–æ–∂–µ—Å—Ç–∏
                similar_candidates.append({
                    "metadata": sample,
                    "similarity_score": similarity_score,
                    "path": sample.path,
                    "filename": sample.filename,
                    "instrument_role": sample.instrument_role,
                    "tempo": sample.tempo,
                    "energy_level": sample.energy_level,
                    "tags": sample.tags
                })
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø–æ—Ö–æ–∂–µ—Å—Ç–∏
        similar_candidates.sort(key=lambda x: x["similarity_score"], reverse=True)
        
        results = similar_candidates[:max_results]
        self.logger.info(f"  ‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(results)} –ø–æ—Ö–æ–∂–∏—Ö —Å—ç–º–ø–ª–æ–≤")
        
        return results
    
    def _calculate_similarity_score(self, ref_sample: SampleMetadata, candidate: SampleMetadata) -> float:
        """
        –†–∞—Å—á—ë—Ç —Å–∫–æ—Ä–∞ –ø–æ—Ö–æ–∂–µ—Å—Ç–∏ –º–µ–∂–¥—É –¥–≤—É–º—è –†–ï–ê–õ–¨–ù–´–ú–ò —Å—ç–º–ø–ª–∞–º–∏
        """
        score = 0.0
        
        # 1. –ü–æ—Ö–æ–∂–µ—Å—Ç—å –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É (40%)
        if (ref_sample.instrument_role and candidate.instrument_role and 
            ref_sample.instrument_role == candidate.instrument_role):
            score += 0.4
        
        # 2. –ü–æ—Ö–æ–∂–µ—Å—Ç—å –ø–æ —Ç–µ–º–ø—É (25%)
        if ref_sample.tempo and candidate.tempo:
            tempo_diff = abs(ref_sample.tempo - candidate.tempo)
            if tempo_diff <= 5:
                score += 0.25
            elif tempo_diff <= 15:
                score += 0.15
            elif tempo_diff <= 30:
                score += 0.05
        
        # 3. –ü–æ—Ö–æ–∂–µ—Å—Ç—å –ø–æ —ç–Ω–µ—Ä–≥–∏–∏ (15%)
        energy_diff = abs(ref_sample.energy_level - candidate.energy_level)
        energy_similarity = max(0, 1 - energy_diff)
        score += energy_similarity * 0.15
        
        # 4. –ü–æ—Ö–æ–∂–µ—Å—Ç—å –ø–æ –∂–∞–Ω—Ä–∞–º (10%)
        common_genres = set(ref_sample.genres) & set(candidate.genres)
        if common_genres:
            score += 0.1
        
        # 5. –ü–æ—Ö–æ–∂–µ—Å—Ç—å –ø–æ —Ç–µ–≥–∞–º (10%)
        if ref_sample.tags and candidate.tags:
            common_tags = set(ref_sample.tags) & set(candidate.tags)
            if common_tags:
                tag_similarity = len(common_tags) / max(len(ref_sample.tags), len(candidate.tags))
                score += tag_similarity * 0.1
        
        return min(1.0, score)
    
    def validate_sample_index(self) -> Dict[str, Any]:
        """
        –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ —Å—ç–º–ø–ª–æ–≤
        """
        validation_result = {
            "total_samples": len(self.samples_index),
            "valid_files": 0,
            "missing_files": 0,
            "invalid_samples": 0,
            "errors": []
        }
        
        for i, sample in enumerate(self.samples_index):
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
                if os.path.exists(sample.path):
                    validation_result["valid_files"] += 1
                else:
                    validation_result["missing_files"] += 1
                    validation_result["errors"].append(f"Missing file: {sample.path}")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
                if sample.tempo < 1 or sample.tempo > 300:
                    validation_result["invalid_samples"] += 1
                    validation_result["errors"].append(f"Invalid tempo {sample.tempo} for {sample.filename}")
                
                if sample.duration <= 0:
                    validation_result["invalid_samples"] += 1
                    validation_result["errors"].append(f"Invalid duration {sample.duration} for {sample.filename}")
                    
            except Exception as e:
                validation_result["invalid_samples"] += 1
                validation_result["errors"].append(f"Validation error for sample {i}: {e}")
        
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
        if validation_result["total_samples"] > 0:
            validation_result["validity_percentage"] = (
                validation_result["valid_files"] / validation_result["total_samples"] * 100
            )
        else:
            validation_result["validity_percentage"] = 0.0
        
        self.logger.info(f"üìä –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–Ω–¥–µ–∫—Å–∞: {validation_result['validity_percentage']:.1f}% –≤–∞–ª–∏–¥–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤")
        
        return validation_result
    
    def rebuild_index_from_directory(self, scan_directory: str = None) -> int:
        """
        –≠–ö–°–¢–†–ï–ù–ù–û–ï –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Å–Ω–æ–≤–Ω–æ–π –∏–Ω–¥–µ–∫—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
        """
        scan_dir = scan_directory or self.sample_dir
        
        if not os.path.exists(scan_dir):
            self.logger.error(f"‚ùå –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {scan_dir}")
            return 0
        
        self.logger.info(f"üîç –≠–ö–°–¢–†–ï–ù–ù–û–ï –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞ –∏–∑ {scan_dir}")
        
        new_samples = []
        processed = 0
        
        # –°–∫–∞–Ω–∏—Ä—É–µ–º –≤—Å–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã
        audio_extensions = {'.wav', '.mp3', '.aif', '.aiff', '.flac', '.ogg', '.m4a'}
        
        for root, dirs, files in os.walk(scan_dir):
            for file in files:
                if any(file.lower().endswith(ext) for ext in audio_extensions):
                    full_path = os.path.join(root, file)
                    
                    try:
                        # –ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ —Ñ–∞–π–ª–∞
                        sample_metadata = self._quick_analyze_audio_file(full_path, file)
                        if sample_metadata:
                            new_samples.append(sample_metadata)
                            processed += 1
                            
                            if processed % 50 == 0:
                                self.logger.info(f"  üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {processed} —Ñ–∞–π–ª–æ–≤")
                    
                    except Exception as e:
                        self.logger.debug(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {file}: {e}")
        
        # –ó–∞–º–µ–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å
        self.samples_index = new_samples
        
        self.logger.info(f"üéØ –≠–ö–°–¢–†–ï–ù–ù–û–ï –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: {len(new_samples)} —Å—ç–º–ø–ª–æ–≤")
        return len(new_samples)
    
    def _quick_analyze_audio_file(self, file_path: str, filename: str) -> Optional[SampleMetadata]:
        """
        –ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏–Ω–¥–µ–∫—Å–∞
        """
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —á–µ—Ä–µ–∑ pydub (–±—ã—Å—Ç—Ä–µ–µ librosa)
            audio = AudioSegment.from_file(file_path)
            duration = len(audio) / 1000.0
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–µ/–¥–ª–∏–Ω–Ω—ã–µ
            if duration < 0.1 or duration > 600:
                return None
            
            # –ü—Ä–æ—Å—Ç–æ–π –∞–Ω–∞–ª–∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
            filename_lower = filename.lower()
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º BPM –∏–∑ –∏–º–µ–Ω–∏ - –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
            tempo = 120  # –î–µ—Ñ–æ–ª—Ç
            bpm_match = re.search(r'(\d{2,3})\s*bpm', filename_lower)
            if bpm_match:
                found_bpm = int(bpm_match.group(1))
                if 60 <= found_bpm <= 200:
                    tempo = found_bpm
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –∏–∑ –∏–º–µ–Ω–∏
            instrument_role = None
            instrument_keywords = {
                'kick': ['kick', 'bd', 'bassdrum'],
                'snare': ['snare', 'sd'],
                'hihat': ['hihat', 'hh', 'hat'],
                'bass': ['bass', 'sub', '808'],
                'lead': ['lead', 'melody', 'synth'],
                'pad': ['pad', 'chord'],
                'vocal': ['vocal', 'voice'],
                'fx': ['fx', 'effect', 'sweep']
            }
            
            for instrument, keywords in instrument_keywords.items():
                if any(kw in filename_lower for kw in keywords):
                    instrument_role = instrument
                    break
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–≥–∏ –∏–∑ –∏–º–µ–Ω–∏ –∏ –ø—É—Ç–∏
            tags = []
            path_lower = file_path.lower()
            
            tag_keywords = {
                'energetic': ['energy', 'high', 'intense'],
                'dark': ['dark', 'noir', 'shadow'],
                'aggressive': ['aggressive', 'hard', 'heavy'],
                'chill': ['chill', 'relax', 'calm'],
                'melodic': ['melodic', 'melody']
            }
            
            for tag, keywords in tag_keywords.items():
                if any(kw in path_lower for kw in keywords):
                    tags.append(tag)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∂–∞–Ω—Ä –∏–∑ –ø—É—Ç–∏
            genres = []
            genre_keywords = ['trap', 'drill', 'lofi', 'dnb', 'house', 'techno', 'ambient']
            for genre in genre_keywords:
                if genre in path_lower:
                    genres.append(genre)
            
            # –°–æ–∑–¥–∞—ë–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            metadata = SampleMetadata(
                path=file_path,
                filename=filename,
                duration=duration,
                tempo=tempo,
                key=None,
                tags=tags,
                genres=genres,
                instrument_role=instrument_role,
                quality_score=0.6,  # –°—Ä–µ–¥–Ω–∏–π –±–∞–ª–ª –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                energy_level=1.0 if 'energetic' in tags else 0.5,
                category="oneshot" if duration < 8 else "loop"
            )
            
            return metadata
            
        except Exception as e:
            self.logger.debug(f"–û—à–∏–±–∫–∞ –±—ã—Å—Ç—Ä–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ {filename}: {e}")
            return None

# ============================================================================
# –°–û–í–ú–ï–°–¢–ò–ú–ê–Ø –û–ë–ï–†–¢–ö–ê –î–õ–Ø –°–¢–ê–†–û–ì–û –ò–ù–¢–ï–†–§–ï–ô–°–ê
# ============================================================================

class SemanticSampleEngine(FixedSemanticSampleEngine):
    """
    –°–æ–≤–º–µ—Å—Ç–∏–º–∞—è –æ–±—ë—Ä—Ç–∫–∞ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Å—Ç–∞—Ä–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    –ü—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è–µ—Ç –≤—ã–∑–æ–≤—ã –∫ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
    """
    
    def __init__(self, sample_dir: str = None):
        super().__init__(sample_dir)
        self.logger.info("üîÑ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–æ–≤–º–µ—Å—Ç–∏–º–∞—è –æ–±—ë—Ä—Ç–∫–∞ SemanticSampleEngine")

# ============================================================================
# –°–ò–°–¢–ï–ú–´ –≠–§–§–ï–ö–¢–û–í (–°–û–í–ú–ï–°–¢–ò–ú–û–°–¢–¨)
# ============================================================================

class EffectsProcessor:
    """–ë–∞–∑–æ–≤—ã–π –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä —ç—Ñ—Ñ–µ–∫—Ç–æ–≤"""
    
    def __init__(self, name: str):
        self.name = name
        self.logger = logging.getLogger(f"{__name__}.{name}")
    
    async def process(self, audio: AudioSegment, params: Dict) -> AudioSegment:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –∫ –∞—É–¥–∏–æ"""
        raise NotImplementedError

class EQProcessor(EffectsProcessor):
    """–ü—Ä–æ—Å—Ç–æ–π EQ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä"""
    
    def __init__(self):
        super().__init__("EQ")
    
    async def process(self, audio: AudioSegment, params: Dict) -> AudioSegment:
        try:
            processed = audio
            
            low_gain = params.get("low", 0)
            high_gain = params.get("high", 0)
            
            # –ü—Ä–æ—Å—Ç–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è EQ —á–µ—Ä–µ–∑ —Ñ–∏–ª—å—Ç—Ä—ã
            if low_gain != 0:
                if low_gain > 0:
                    low_filtered = processed.low_pass_filter(300) + low_gain
                    processed = processed.overlay(low_filtered - processed.low_pass_filter(300))
            
            if high_gain != 0:
                if high_gain > 0:
                    high_filtered = processed.high_pass_filter(3000) + high_gain
                    processed = processed.overlay(high_filtered - processed.high_pass_filter(3000))
            
            return processed
        except Exception as e:
            self.logger.error(f"EQ error: {e}")
            return audio

class CompressorProcessor(EffectsProcessor):
    """–ü—Ä–æ—Å—Ç–æ–π –∫–æ–º–ø—Ä–µ—Å—Å–æ—Ä"""
    
    def __init__(self):
        super().__init__("Compressor")
    
    async def process(self, audio: AudioSegment, params: Dict) -> AudioSegment:
        try:
            threshold = params.get("threshold", -12)
            ratio = params.get("ratio", 2.0)
            
            if audio.max_dBFS > threshold and ratio > 1:
                reduction = (audio.max_dBFS - threshold) * (1 - 1/ratio)
                processed = audio - reduction
                return processed
            
            return audio
        except Exception as e:
            self.logger.error(f"Compressor error: {e}")
            return audio

class SaturationProcessor(EffectsProcessor):
    """–ü—Ä–æ—Å—Ç–æ–µ –Ω–∞—Å—ã—â–µ–Ω–∏–µ"""
    
    def __init__(self):
        super().__init__("Saturation")
    
    async def process(self, audio: AudioSegment, params: Dict) -> AudioSegment:
        try:
            amount = params.get("amount", 0.0)
            if amount > 0:
                # –ü—Ä–æ—Å—Ç–∞—è —Å–∏–º—É–ª—è—Ü–∏—è –Ω–∞—Å—ã—â–µ–Ω–∏—è —á–µ—Ä–µ–∑ –Ω–µ–±–æ–ª—å—à–æ–π –ø–æ–¥—ä—ë–º
                processed = audio + (amount * 1.5)
                return processed
            return audio
        except Exception as e:
            self.logger.error(f"Saturation error: {e}")
            return audio

class StereoProcessor(EffectsProcessor):
    """–ü—Ä–æ—Å—Ç–∞—è —Å—Ç–µ—Ä–µ–æ –æ–±—Ä–∞–±–æ—Ç–∫–∞"""
    
    def __init__(self):
        super().__init__("Stereo")
    
    async def process(self, audio: AudioSegment, params: Dict) -> AudioSegment:
        try:
            width = params.get("width", 1.0)
            
            if audio.channels < 2:
                audio = audio.set_channels(2)
            
            # –ü—Ä–æ—Å—Ç–∞—è —Å—Ç–µ—Ä–µ–æ –æ–±—Ä–∞–±–æ—Ç–∫–∞
            return audio
        except Exception as e:
            self.logger.error(f"Stereo error: {e}")
            return audio

class LimiterProcessor(EffectsProcessor):
    """–ü—Ä–æ—Å—Ç–æ–π –ª–∏–º–∏—Ç–µ—Ä"""
    
    def __init__(self):
        super().__init__("Limiter")
    
    async def process(self, audio: AudioSegment, params: Dict) -> AudioSegment:
        try:
            ceiling = params.get("ceiling", -0.1)
            
            if audio.max_dBFS > ceiling:
                reduction = audio.max_dBFS - ceiling
                processed = audio - reduction
                return processed
            
            return audio
        except Exception as e:
            self.logger.error(f"Limiter error: {e}")
            return audio

class ReverbProcessor(EffectsProcessor):
    """–ü—Ä–æ—Å—Ç–æ–π —Ä–µ–≤–µ—Ä–±"""
    
    def __init__(self):
        super().__init__("Reverb")
    
    async def process(self, audio: AudioSegment, params: Dict) -> AudioSegment:
        try:
            wet_level = params.get("wet_level", 0.2)
            
            if wet_level > 0:
                # –û—á–µ–Ω—å –ø—Ä–æ—Å—Ç–∞—è —Å–∏–º—É–ª—è—Ü–∏—è —Ä–µ–≤–µ—Ä–±–∞ —á–µ—Ä–µ–∑ –∑–∞–¥–µ—Ä–∂–∫—É
                delay_ms = 80
                delayed = AudioSegment.silent(duration=delay_ms) + audio
                delayed = delayed.apply_gain(-20 * (1 - wet_level))
                
                # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω–µ
                max_len = max(len(audio), len(delayed))
                if len(audio) < max_len:
                    audio = audio + AudioSegment.silent(duration=max_len - len(audio))
                if len(delayed) < max_len:
                    delayed = delayed + AudioSegment.silent(duration=max_len - len(delayed))
                
                return audio.overlay(delayed)
            
            return audio
        except Exception as e:
            self.logger.error(f"Reverb error: {e}")
            return audio

class EffectsChain:
    """–¶–µ–ø–æ—á–∫–∞ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä—ã
        self.processors = {
            "eq": EQProcessor(),
            "compressor": CompressorProcessor(),
            "saturation": SaturationProcessor(),
            "stereo": StereoProcessor(),
            "limiter": LimiterProcessor(),
            "reverb": ReverbProcessor()
        }
        
        self.logger.info(f"‚úÖ Effects chain ready: {list(self.processors.keys())}")
    
    async def apply_effects(self, audio: AudioSegment, effects_config: Dict) -> AudioSegment:
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–ø–æ—á–∫–∏ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤"""
        if not effects_config:
            return audio
        
        processed = audio
        effect_order = ["eq", "compressor", "saturation", "reverb", "stereo", "limiter"]
        
        for effect_name in effect_order:
            if effect_name in effects_config and effect_name in self.processors:
                try:
                    effect_params = effects_config[effect_name]
                    processed = await self.processors[effect_name].process(processed, effect_params)
                except Exception as e:
                    self.logger.error(f"Error applying {effect_name}: {e}")
        
        return processed

# ============================================================================
# –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
# ============================================================================

def validate_audio_file(filepath: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞"""
    try:
        if not os.path.exists(filepath):
            return False
        
        file_size = os.path.getsize(filepath)
        if file_size < 1024:  # –ú–µ–Ω—å—à–µ 1KB
            return False
        
        # –ü—Ä–æ–±—É–µ–º –∑–∞–≥—Ä—É–∑–∏—Ç—å
        audio = AudioSegment.from_file(filepath)
        duration = len(audio) / 1000
        
        return 0.1 <= duration <= 600  # –û—Ç 0.1 —Å–µ–∫ –¥–æ 10 –º–∏–Ω—É—Ç
        
    except Exception:
        return False

def extract_bpm_from_filename(filename: str) -> Optional[int]:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ BPM –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞ - –ò–°–ü–†–ê–í–õ–ï–ù–û"""
    patterns = [
        r'(\d{2,3})\s*bpm',
        r'(\d{2,3})\s*beats',
        r'tempo[\s_-]*(\d{2,3})',
        r'(\d{2,3})[\s_-]*beat'
    ]
    
    filename_lower = filename.lower()
    
    for pattern in patterns:
        match = re.search(pattern, filename_lower)
        if match:
            bpm = int(match.group(1))
            if 60 <= bpm <= 200:
                return bpm
    
    return None

def extract_key_from_filename(filename: str) -> Optional[str]:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
    patterns = [
        r'\b([a-g][#b]?)\s*m(?:inor|in)?\b',
        r'\b([a-g][#b]?)\s*maj(?:or)?\b',
        r'key[\s_-]*([a-g][#b]?)\b'
    ]
    
    filename_lower = filename.lower()
    
    for pattern in patterns:
        match = re.search(pattern, filename_lower)
        if match:
            return match.group(1).upper()
    
    return None

# ============================================================================
# –≠–ö–°–ü–û–†–¢ –û–°–ù–û–í–ù–´–• –ö–õ–ê–°–°–û–í
# ============================================================================

__all__ = [
    'FixedSemanticSampleEngine',
    'SemanticSampleEngine',  # –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
    'EffectsChain',
    'SampleMetadata',
    'validate_audio_file',
    'extract_bpm_from_filename',
    'extract_key_from_filename'
]

# ============================================================================
# –¢–ï–°–¢ –ú–û–î–£–õ–Ø
# ============================================================================

if __name__ == "__main__":
    import asyncio
    
    async def test_semantic_engine():
        """–¢–µ—Å—Ç —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –¥–≤–∏–∂–∫–∞"""
        print("üß™ –¢–µ—Å—Ç–∏—Ä—É–µ–º –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –¥–≤–∏–∂–æ–∫")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        engine = FixedSemanticSampleEngine()
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        stats = engine.get_samples_statistics()
        print(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: {stats}")
        
        if stats["total_samples"] > 0:
            # –¢–µ—Å—Ç –ø–æ–∏—Å–∫–∞
            print("\nüîç –¢–µ—Å—Ç –ø–æ–∏—Å–∫–∞...")
            results = await engine.find_samples(
                tags=["trap", "dark"],
                instruments=["kick", "808"],
                genre="trap",
                bpm=140,
                max_results=5
            )
            
            print(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ: {len(results)} —Å—ç–º–ø–ª–æ–≤")
            for i, result in enumerate(results, 1):
                print(f"  {i}. {result['filename']} (—Å–∫–æ—Ä: {result['score']:.3f})")
        
        else:
            print("‚ùå –ù–µ—Ç —Å—ç–º–ø–ª–æ–≤ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è")
            print("‚ùå –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ —Ñ–∞–π–ª sample_index.json —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
    
    # –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–∞
    asyncio.run(test_semantic_engine())# sample_engine_FIXED.py - –ü–û–õ–ù–û–°–¢–¨–Æ –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –¥–≤–∏–∂–æ–∫
# 
# ‚úÖ –û–°–ù–û–í–ù–´–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
# - –ü–æ–ª–Ω–æ—Å—Ç—å—é —É–±—Ä–∞–Ω–∞ —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—ç–º–ø–ª–æ–≤ 
# - –†–∞–±–æ—Ç–∞–µ—Ç –¢–û–õ–¨–ö–û —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ —Å—ç–º–ø–ª–∞–º–∏ –∏–∑ —Ç–≤–æ–µ–≥–æ JSON –∏–Ω–¥–µ–∫—Å–∞
# - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ –æ–ø–µ—á–∞—Ç–∫–∏ bmp -> bpm
# - –ß–µ—Å—Ç–Ω—ã–π —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ —Å–∫–æ—Ä–∞–º–∏
# - –£–¥–∞–ª–µ–Ω—ã –≤—Å–µ fallback'–∏ –Ω–∞ —Å–æ–∑–¥–∞–Ω–∏–µ —Ñ–µ–π–∫–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
