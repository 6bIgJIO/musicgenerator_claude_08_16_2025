import os
import sys
import asyncio
import logging
import time
import json
import io
import pickle
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, field
from enum import Enum
import traceback
import subprocess
import requests
import hashlib
import re

# –ê—É–¥–∏–æ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
from pydub import AudioSegment, effects
from pydub.effects import compress_dynamic_range, normalize
from pydub.generators import Sine, WhiteNoise
import librosa
import soundfile as sf
import numpy as np

from config import config, GenreType, MasteringPurpose
from sample_engine import SemanticSampleEngine, EffectsChain
from verification import MixVerifier
from export import ExportManager
from metadata import MetadataProcessor


# ML/AI –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ)
try:
    from sentence_transformers import SentenceTransformer
    from sklearn.metrics.pairwise import cosine_similarity
    from sklearn.cluster import KMeans
    SEMANTIC_AVAILABLE = True
except ImportError:
    SEMANTIC_AVAILABLE = False

# MusicGen (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π)
try:
    import torch
    from audiocraft.models import musicgen
    MUSICGEN_AVAILABLE = True
except ImportError:
    MUSICGEN_AVAILABLE = False

# ============================================================================
# –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø –ò –≠–ù–£–ú–´
# ============================================================================

class MasteringPurpose(Enum):
    FREELANCE = "freelance"
    PROFESSIONAL = "professional"
    PERSONAL = "personal"
    FAMILY = "family"
    STREAMING = "streaming"
    VINYL = "vinyl"

class GenreType(Enum):
    TRAP = "trap"
    PHONK = "phonk"
    LOFI = "lofi"
    AMBIENT = "ambient"
    EDM = "edm"
    DNB = "dnb"
    TECHNO = "techno"
    HOUSE = "house"
    CINEMATIC = "cinematic"
    HYPERPOP = "hyperpop"
    DRILL = "drill"
    JERSEY = "jersey"

@dataclass
class GenreConfig:
    name: str
    bpm_range: Tuple[int, int]  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
    core_instruments: List[str]
    optional_instruments: List[str]
    default_tags: List[str]
    mastering_style: str
    energy_range: Tuple[float, float] = (0.3, 0.9)
    default_structure: List[Dict[str, Any]] = field(default_factory=list)

class WaveDreamConfig:
    """–¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è"""
    
    def __init__(self):
        # –ü—É—Ç–∏
        self.DEFAULT_SAMPLE_DIR = self._find_sample_directory()
        self.DEFAULT_OUTPUT_DIR = "wavedream_output"
        self.CACHE_DIR = "wavedream_cache"
        self.MUSICGEN_MODEL_PATH = r"D:\2027\audiocraft\audiocraft\models\facebook\musicgen-medium"
        
        # –§–∞–π–ª—ã
        self.INDEX_FILE = "wavedream_sample_index.json"
        self.SEMANTIC_CACHE_FILE = "semantic_embeddings.pkl"
        
        # –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        os.makedirs(self.DEFAULT_OUTPUT_DIR, exist_ok=True)
        os.makedirs(self.CACHE_DIR, exist_ok=True)
    
    def _find_sample_directory(self) -> str:
        """–ü–æ–∏—Å–∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å—ç–º–ø–ª–æ–≤"""
        candidates = [
            r"D:\0\—à–∞–±–ª–æ–Ω—ã\Samples for AKAI",
            "samples",
            "audio_samples",
            os.path.join(os.path.expanduser("~"), "Documents", "Samples")
        ]
        
        for path in candidates:
            if os.path.exists(path):
                return path
        
        # –°–æ–∑–¥–∞—ë–º –¥–µ—Ñ–æ–ª—Ç–Ω—É—é
        os.makedirs("samples", exist_ok=True)
        return "samples"
    
    @property
    def GENRE_CONFIGS(self) -> Dict[str, GenreConfig]:
        return {
            "trap": GenreConfig(
                name="trap",
                bpm_range=(130, 170),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
                core_instruments=["kick", "snare", "hihat", "bass", "808"],
                optional_instruments=["bell", "lead", "vocal", "fx"],
                default_tags=["808", "trap", "dark", "urban", "aggressive"],
                mastering_style="punchy_aggressive",
                energy_range=(0.6, 0.9),
                default_structure=[
                    {"type": "intro", "duration": 8, "energy": 0.3},
                    {"type": "verse", "duration": 16, "energy": 0.5},
                    {"type": "hook", "duration": 16, "energy": 0.8},
                    {"type": "verse", "duration": 16, "energy": 0.6},
                    {"type": "hook", "duration": 16, "energy": 0.9},
                    {"type": "outro", "duration": 8, "energy": 0.4}
                ]
            ),
            "lofi": GenreConfig(
                name="lofi",
                bpm_range=(60, 85),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
                core_instruments=["soft_kick", "snare", "rim", "vinyl_fx"],
                optional_instruments=["piano", "pad", "jazz_guitar", "rain"],
                default_tags=["lofi", "chill", "vintage", "cozy", "nostalgic"],
                mastering_style="warm_cozy",
                energy_range=(0.2, 0.5),
                default_structure=[
                    {"type": "intro", "duration": 15, "energy": 0.2},
                    {"type": "verse", "duration": 30, "energy": 0.4},
                    {"type": "bridge", "duration": 20, "energy": 0.3},
                    {"type": "verse", "duration": 30, "energy": 0.5},
                    {"type": "outro", "duration": 15, "energy": 0.2}
                ]
            ),
            "dnb": GenreConfig(
                name="dnb",
                bpm_range=(160, 180),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
                core_instruments=["kick", "snare_dnb", "break", "reese_bass"],
                optional_instruments=["pad", "lead", "vocal", "fx"],
                default_tags=["dnb", "neurofunk", "liquid", "breakbeat", "bass"],
                mastering_style="tight_punchy",
                energy_range=(0.7, 1.0),
                default_structure=[
                    {"type": "intro", "duration": 16, "energy": 0.4},
                    {"type": "buildup", "duration": 16, "energy": 0.6},
                    {"type": "drop", "duration": 32, "energy": 0.9},
                    {"type": "breakdown", "duration": 16, "energy": 0.5},
                    {"type": "drop", "duration": 32, "energy": 1.0},
                    {"type": "outro", "duration": 16, "energy": 0.3}
                ]
            ),
            "drill": GenreConfig(
                name="drill",
                bpm_range=(140, 160),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
                core_instruments=["kick", "snare", "drill_hat", "sliding_808"],
                optional_instruments=["bell", "vocal", "fx", "piano"],
                default_tags=["drill", "uk_drill", "sliding_808", "aggressive"],
                mastering_style="punchy_aggressive",
                energy_range=(0.7, 0.9),
                default_structure=[
                    {"type": "intro", "duration": 8, "energy": 0.4},
                    {"type": "verse", "duration": 16, "energy": 0.6},
                    {"type": "hook", "duration": 16, "energy": 0.8},
                    {"type": "verse", "duration": 16, "energy": 0.7},
                    {"type": "hook", "duration": 16, "energy": 0.9},
                    {"type": "outro", "duration": 8, "energy": 0.5}
                ]
            ),
            "cinematic": GenreConfig(
                name="cinematic",
                bpm_range=(70, 120),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
                core_instruments=["strings", "brass", "percussion", "choir"],
                optional_instruments=["piano", "harp", "fx", "trailer_hits"],
                default_tags=["cinematic", "epic", "orchestral", "trailer", "heroic"],
                mastering_style="cinematic_wide",
                energy_range=(0.3, 1.0),
                default_structure=[
                    {"type": "intro", "duration": 20, "energy": 0.2},
                    {"type": "buildup", "duration": 30, "energy": 0.5},
                    {"type": "climax", "duration": 40, "energy": 0.9},
                    {"type": "resolution", "duration": 30, "energy": 0.6},
                    {"type": "outro", "duration": 20, "energy": 0.3}
                ]
            ),
            "ambient": GenreConfig(
                name="ambient",
                bpm_range=(60, 90),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
                core_instruments=["pad", "texture", "drone", "ambient_fx"],
                optional_instruments=["piano", "strings", "field_recording", "bells"],
                default_tags=["ambient", "ethereal", "spacious", "meditation", "peaceful"],
                mastering_style="spacious_ethereal",
                energy_range=(0.1, 0.4),
                default_structure=[
                    {"type": "emergence", "duration": 45, "energy": 0.1},
                    {"type": "development", "duration": 90, "energy": 0.3},
                    {"type": "climax", "duration": 60, "energy": 0.4},
                    {"type": "resolution", "duration": 45, "energy": 0.2}
                ]
            )
        }
    
    @property
    def MASTERING_CONFIGS(self) -> Dict[str, Dict]:
        return {
            "freelance": {
                "target_lufs": -14,
                "peak_ceiling": -1,
                "dynamic_range": 8,
                "character": "punchy commercial sound optimized for streaming"
            },
            "professional": {
                "target_lufs": -23,
                "peak_ceiling": -3,
                "dynamic_range": 12,
                "character": "professional broadcast-ready with full dynamic range"
            },
            "personal": {
                "target_lufs": -16,
                "peak_ceiling": -2,
                "dynamic_range": 10,
                "character": "clean natural sound for personal listening"
            }
        }
    
    def get_genre_config(self, genre: str) -> Optional[GenreConfig]:
        return self.GENRE_CONFIGS.get(genre.lower())
    
    def get_mastering_config(self, purpose: str) -> Dict:
        return self.MASTERING_CONFIGS.get(purpose, self.MASTERING_CONFIGS["personal"])

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ñ–∏–≥–∞
config = WaveDreamConfig()

# ============================================================================
# –û–°–ù–û–í–ù–´–ï –î–ê–¢–ê–ö–õ–ê–°–°–´
# ============================================================================

@dataclass
class GenerationRequest:
    prompt: str
    genre: Optional[str] = None
    bpm: Optional[int] = None  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
    duration: Optional[int] = None
    mastering_purpose: str = "personal"
    output_dir: str = "output"
    export_stems: bool = True
    energy_level: float = 0.5
    creativity_factor: float = 0.7

@dataclass
class GenerationResult:
    success: bool
    final_path: Optional[str] = None
    structure_data: Optional[Dict] = None
    used_samples: Optional[List[Dict]] = None
    generation_time: float = 0.0
    quality_score: float = 0.0
    error_message: Optional[str] = None
    intermediate_files: Optional[Dict[str, str]] = None

@dataclass
class SampleMetadata:
    path: str
    filename: str
    duration: float
    tempo: int
    key: Optional[str]
    tags: List[str]
    genres: List[str]
    instrument_role: Optional[str]
    quality_score: float = 0.0
    energy_level: float = 0.0

# ============================================================================
# LLAMA3-MUSIC –ö–õ–ò–ï–ù–¢ (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô)
# ============================================================================

class LlamaStructureClient:
    """–ö–ª–∏–µ–Ω—Ç –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ LLama3-music"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.ollama_models = ["llama3-music", "llama3", "mistral7b"]
    
    def query_structured_music(self, prompt: str) -> Optional[Dict]:
        """–ó–∞–ø—Ä–æ—Å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫ LLama3-music"""
        self.logger.info("üß† –ó–∞–ø—Ä–æ—Å —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫ LLama3-music")
        
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ API
        result = self._try_ollama_api(prompt)
        if result:
            return result
        
        # Fallback –Ω–∞ subprocess
        return self._try_ollama_subprocess(prompt)
    
    def _try_ollama_api(self, prompt: str) -> Optional[Dict]:
        """–ü–æ–ø—ã—Ç–∫–∞ —á–µ—Ä–µ–∑ Ollama HTTP API"""
        system_prompt = """–¢—ã –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞ –≤ JSON.
        
–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –¢–û–õ–¨–ö–û JSON:
{
  "bpm": —á–∏—Å–ª–æ_–æ—Ç_60_–¥–æ_180,
  "structure": [
    {"type": "intro", "duration": 8},
    {"type": "verse", "duration": 16},
    {"type": "hook", "duration": 16}
  ]
}

–¢–æ–ª—å–∫–æ JSON, –Ω–∏–∫–∞–∫–∏—Ö –æ–±—ä—è—Å–Ω–µ–Ω–∏–π!"""
        
        full_prompt = f"{system_prompt}\n\n–¢—Ä–µ–∫: {prompt}"
        
        for model in self.ollama_models:
            try:
                self.logger.info(f"  üîÑ –ü—Ä–æ–±—É–µ–º {model}")
                
                response = requests.post(
                    "http://localhost:11434/api/generate",
                    json={
                        "model": model,
                        "prompt": full_prompt,
                        "stream": False,
                        "options": {
                            "temperature": 0.1,
                            "num_predict": 500
                        }
                    },
                    timeout=60
                )
                
                if response.status_code == 200:
                    data = response.json()
                    raw_output = data.get("response", "")
                    
                    if raw_output:
                        parsed = self._parse_json_response(raw_output)
                        if parsed:
                            self.logger.info(f"  ‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–ª—É—á–µ–Ω–∞ –æ—Ç {model}")
                            return parsed
                
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∞—É–¥–∏–æ: {e}")
                return False


    def _try_ollama_subprocess(self, prompt: str) -> Optional[Dict]:
        """–§–æ–ª–ª–±–µ–∫ —á–µ—Ä–µ–∑ subprocess, –µ—Å–ª–∏ API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"""
        try:
            cmd = [
                "ollama", "run", "llama3-music",
                f"–¢—ã –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ —Ç—Ä–µ–∫–∞ –≤ JSON.\n\n"
                f"–°–≥–µ–Ω–µ—Ä–∏—Ä—É–π –¢–û–õ–¨–ö–û JSON:\n"
                f'{{"bpm": —á–∏—Å–ª–æ_–æ—Ç_60_–¥–æ_180,"structure":[{{"type":"intro","duration":8}}]}}\n\n'
                f"–¢—Ä–µ–∫: {prompt}"
            ]
            self.logger.info("  üñ•Ô∏è –ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ subprocess ollama")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            if result.returncode == 0 and result.stdout:
                return self._parse_json_response(result.stdout)
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ ollama subprocess: {e}")
        return None
    
    
    def _parse_json_response(self, raw_output: str) -> Optional[Dict]:
        """–ß–∏—Å—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –º–æ–¥–µ–ª–∏ –∏ –ø–∞—Ä—Å–∏–Ω–≥ JSON"""
        try:
            match = re.search(r'\{.*\}', raw_output, re.DOTALL)
            if not match:
                return None
            json_str = match.group(0)
            return json.loads(json_str)
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: {e}")
            return None



# ============================================================================
# –°–ò–°–¢–ï–ú–ê –≠–ö–°–ü–û–†–¢–ê –ò –ú–ï–¢–ê–î–ê–ù–ù–´–•
# ============================================================================

class ExportManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞ —Å –æ—á–∏—Å—Ç–∫–æ–π –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def save_final_mix(self, audio: Union[AudioSegment, bytes], project_name: str) -> str:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –º–∏–∫—Å–∞"""
        try:
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ AudioSegment –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if isinstance(audio, bytes):
                buffer = io.BytesIO(audio)
                audio_segment = AudioSegment.from_file(buffer, format="wav")
                buffer.close()
            else:
                audio_segment = audio
            
            # –°–æ–∑–¥–∞–µ–º –≤—ã—Ö–æ–¥–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
            output_dir = Path(config.DEFAULT_OUTPUT_DIR) / project_name
            output_dir.mkdir(parents=True, exist_ok=True)
            
            # –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É
            final_path = output_dir / f"{project_name}_final.wav"
            
            # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º
            audio_segment.export(str(final_path), format="wav")
            
            # –û—á–∏—â–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            self._clean_metadata(str(final_path))
            
            self.logger.info(f"üíæ –§–∏–Ω–∞–ª—å–Ω—ã–π –º–∏–∫—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {final_path}")
            return str(final_path)
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –º–∏–∫—Å–∞: {e}")
            return ""
    
    def save_intermediate(self, stage: str, project_name: str, audio: Union[AudioSegment, bytes]) -> str:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤"""
        try:
            if isinstance(audio, bytes):
                buffer = io.BytesIO(audio)
                audio_segment = AudioSegment.from_file(buffer, format="wav")
                buffer.close()
            else:
                audio_segment = audio
            
            output_dir = Path(config.DEFAULT_OUTPUT_DIR) / project_name / "intermediate"
            output_dir.mkdir(parents=True, exist_ok=True)
            
            intermediate_path = output_dir / f"{project_name}_{stage}.wav"
            audio_segment.export(str(intermediate_path), format="wav")
            self.logger.debug(f"  üíæ –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —Ñ–∞–π–ª: {intermediate_path}")
            return str(intermediate_path)
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞: {e}")
            return ""
    
    def save_stem(self, audio: Union[AudioSegment, bytes], project_name: str, stem_name: str) -> str:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å—Ç–µ–º–∞"""
        try:
            if isinstance(audio, bytes):
                buffer = io.BytesIO(audio)
                audio_segment = AudioSegment.from_file(buffer, format="wav")
                buffer.close()
            else:
                audio_segment = audio
            
            output_dir = Path(config.DEFAULT_OUTPUT_DIR) / project_name / "stems"
            output_dir.mkdir(parents=True, exist_ok=True)
            
            stem_path = output_dir / f"{project_name}_{stem_name}.wav"
            audio_segment.export(str(stem_path), format="wav")
            
            self.logger.debug(f"  üíæ –°—Ç–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {stem_path}")
            return str(stem_path)
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–µ–º–∞: {e}")
            return ""
    
    def save_metadata(self, project_name: str, metadata: Dict) -> str:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–∞"""
        try:
            output_dir = Path(config.DEFAULT_OUTPUT_DIR) / project_name
            output_dir.mkdir(parents=True, exist_ok=True)
            
            metadata_path = output_dir / f"{project_name}_metadata.json"
            
            with open(metadata_path, 'w', encoding='utf-8') as f:
                json.dump(metadata, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"üìã –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã: {metadata_path}")
            return str(metadata_path)
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö: {e}")
            return ""
    
    def _clean_metadata(self, audio_path: str):
        """–û—á–∏—Å—Ç–∫–∞ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö –∏–∑ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞"""
        try:
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏ –ø–µ—Ä–µ—Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
            audio = AudioSegment.from_file(audio_path)
            
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            temp_path = audio_path + ".temp"
            
            # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –±–µ–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
            audio.export(temp_path, format="wav", 
                        tags=None,  # –£–±–∏—Ä–∞–µ–º —Ç–µ–≥–∏
                        parameters=["-map_metadata", "-1"])  # –£–¥–∞–ª—è–µ–º –≤—Å–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            
            # –ó–∞–º–µ–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª
            import shutil
            shutil.move(temp_path, audio_path)
            
            self.logger.debug(f"  üßπ –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã: {audio_path}")
        
        except Exception as e:
            self.logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ: {e}")
    
    async def export_complete_project(
        self, 
        mastered_audio: Union[AudioSegment, bytes],
        intermediate_audio: Dict[str, Union[AudioSegment, bytes]],
        export_config: Dict
    ) -> Dict[str, str]:
        """–≠–∫—Å–ø–æ—Ä—Ç –ø–æ–ª–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞"""
        exported_files = {}
        
        try:
            project_name = f"WD_Project_{int(time.time())}"
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫
            final_path = self.save_final_mix(mastered_audio, project_name)
            if final_path:
                exported_files["final_wav"] = final_path
            
            # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
            if isinstance(mastered_audio, bytes):
                buffer = io.BytesIO(mastered_audio)
                audio_segment = AudioSegment.from_file(buffer, format="wav")
                buffer.close()
            else:
                audio_segment = mastered_audio
            
            # MP3 —ç–∫—Å–ø–æ—Ä—Ç
            try:
                output_dir = Path(config.DEFAULT_OUTPUT_DIR) / project_name
                mp3_path = output_dir / f"{project_name}_final.mp3"
                audio_segment.export(str(mp3_path), format="mp3", bitrate="320k")
                self._clean_metadata(str(mp3_path))
                exported_files["final_mp3"] = str(mp3_path)
                self.logger.info(f"üíæ MP3 —ç–∫—Å–ø–æ—Ä—Ç: {mp3_path}")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è MP3 —ç–∫—Å–ø–æ—Ä—Ç –Ω–µ —É–¥–∞–ª—Å—è: {e}")
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ñ–∞–π–ª—ã –µ—Å–ª–∏ –∑–∞–ø—Ä–æ—à–µ–Ω–æ
            if export_config.get("export_stems", False):
                for stage, audio_data in intermediate_audio.items():
                    if stage == "stems" and isinstance(audio_data, dict):
                        # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π —Å—Ç–µ–º
                        for stem_name, stem_audio in audio_data.items():
                            stem_path = self.save_stem(stem_audio, project_name, stem_name)
                            if stem_path:
                                exported_files[f"stem_{stem_name}"] = stem_path
                    else:
                        # –û–±—ã—á–Ω—ã–π –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —Ñ–∞–π–ª
                        intermediate_path = self.save_intermediate(stage, project_name, audio_data)
                        if intermediate_path:
                            exported_files[f"intermediate_{stage}"] = intermediate_path
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–µ–∫—Ç–∞
            project_metadata = {
                "project_name": project_name,
                "generation_time": time.strftime('%Y-%m-%d %H:%M:%S'),
                "config": export_config,
                "exported_files": list(exported_files.keys()),
                "wavedream_version": "Enhanced Pro v2.1"
            }
            
            metadata_path = self.save_metadata(project_name, project_metadata)
            if metadata_path:
                exported_files["metadata"] = metadata_path
            
            self.logger.info(f"üéâ –ü—Ä–æ–µ–∫—Ç —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω: {len(exported_files)} —Ñ–∞–π–ª–æ–≤")
            return exported_files
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞ –ø—Ä–æ–µ–∫—Ç–∞: {e}")
            return exported_files

# ============================================================================
# –ì–õ–ê–í–ù–´–ô PIPELINE (–°–¢–ê–ë–ò–õ–¨–ù–´–ô –° –§–ò–ö–°–ê–ú–ò)
# ============================================================================

class StableWaveDreamPipeline:
    """–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è WaveDream Pipeline —Å —Ñ–∏–∫—Å–∞–º–∏ band_pass_filter"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        self.llama_client = LlamaStructureClient()
        self.musicgen_engine = MusicGenEngine()
        self.sample_engine = SimpleSemanticEngine()
        self.mastering_engine = StableMasteringEngine()
        self.export_manager = ExportManager()
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self._performance_stats = {}
        self._current_project_name = None
        self._intermediate_storage = {}
        
        self.logger.info("üéµ WaveDream Stable Pipeline –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    async def generate_track(self, request: GenerationRequest) -> GenerationResult:
        """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ - –°–¢–ê–ë–ò–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø"""
        start_time = time.time()
        
        try:
            # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è –ø—Ä–æ–µ–∫—Ç–∞
            timestamp = int(time.time())
            self._current_project_name = f"WD_Stable_{timestamp}"
            
            self.logger.info(f"üöÄ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–∫–∞: '{request.prompt}'")
            self.logger.info(f"üìÅ –ü—Ä–æ–µ–∫—Ç: {self._current_project_name}")
            
            # === –≠–¢–ê–ü 1: –ê–ù–ê–õ–ò–ó –ü–†–û–ú–ü–¢–ê ===
            self.logger.info("üìã –≠—Ç–∞–ø 1: –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–º–ø—Ç–∞")
            metadata = await self._analyze_prompt(request)
            
            # === –≠–¢–ê–ü 2: –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ñ–ê–ù–†–ê ===
            self.logger.info("üé≠ –≠—Ç–∞–ø 2: –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞")
            genre_info = await self._determine_genre(request, metadata)
            
            # === –≠–¢–ê–ü 3: –ì–ï–ù–ï–†–ê–¶–ò–Ø –°–¢–†–£–ö–¢–£–†–´ ===
            self.logger.info("üèóÔ∏è –≠—Ç–∞–ø 3: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã")
            structure = await self._generate_structure(request, genre_info)
            
            # === –≠–¢–ê–ü 4: –ì–ï–ù–ï–†–ê–¶–ò–Ø –ë–ê–ó–´ MUSICGEN ===
            self.logger.info("üéº –≠—Ç–∞–ø 4: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –±–∞–∑—ã MusicGen")
            base_audio_bytes = await self._generate_base_track(request, structure, genre_info)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–∞–∑–æ–≤—É—é –¥–æ—Ä–æ–∂–∫—É
            base_path = self.export_manager.save_intermediate(
                "01_base_generated", self._current_project_name, base_audio_bytes
            )
            self._intermediate_storage["base"] = base_path
            
            # === –≠–¢–ê–ü 5: –ü–û–î–ë–û–† –°–≠–ú–ü–õ–û–í ===
            self.logger.info("üéõÔ∏è –≠—Ç–∞–ø 5: –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–¥–±–æ—Ä —Å—ç–º–ø–ª–æ–≤")
            selected_samples = await self._select_samples(request, structure, genre_info)
            
            # === –≠–¢–ê–ü 6: –°–û–ó–î–ê–ù–ò–ï –°–¢–ï–ú–û–í ===
            self.logger.info("üéöÔ∏è –≠—Ç–∞–ø 6: –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–º–æ–≤")
            stems_dict = await self._create_stems(selected_samples, structure, genre_info)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–∂–¥—ã–π —Å—Ç–µ–º
            stem_paths = {}
            for instrument, stem_bytes in stems_dict.items():
                stem_path = self.export_manager.save_stem(
                    stem_bytes, self._current_project_name, f"stem_{instrument}"
                )
                if stem_path:
                    stem_paths[instrument] = stem_path
            
            self._intermediate_storage["stems"] = stem_paths
            
            # === –≠–¢–ê–ü 7: –ú–ò–ö–®–ò–†–û–í–ê–ù–ò–ï ===
            self.logger.info("üéöÔ∏è –≠—Ç–∞–ø 7: –ú–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏–µ")
            mixed_audio = await self._mix_tracks(base_audio_bytes, stems_dict, genre_info)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∏–∫—Å
            mixed_path = self.export_manager.save_intermediate(
                "02_mixed", self._current_project_name, mixed_audio
            )
            self._intermediate_storage["mixed"] = mixed_path
            
            # === –≠–¢–ê–ü 8: –ú–ê–°–¢–ï–†–ò–ù–ì ===
            self.logger.info("üéõÔ∏è –≠—Ç–∞–ø 8: –£–º–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥")
            mastered_audio, mastering_config = await self.mastering_engine.master_track(
                mixed_audio, 
                config.get_mastering_config(request.mastering_purpose),
                genre_info,
                request.mastering_purpose
            )
            
            # === –≠–¢–ê–ü 9: –§–ò–ù–ê–õ–¨–ù–´–ô –≠–ö–°–ü–û–†–¢ ===
            self.logger.info("üíæ –≠—Ç–∞–ø 9: –§–∏–Ω–∞–ª—å–Ω—ã–π —ç–∫—Å–ø–æ—Ä—Ç")
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º mastered_audio –≤ bytes –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞
            if isinstance(mastered_audio, AudioSegment):
                buffer = io.BytesIO()
                mastered_audio.export(buffer, format="wav")
                mastered_bytes = buffer.getvalue()
                buffer.close()
            else:
                mastered_bytes = mastered_audio
            
            # –≠–∫—Å–ø–æ—Ä—Ç
            export_config = {
                "export_stems": request.export_stems,
                "request_data": {
                    "prompt": request.prompt,
                    "genre": request.genre,
                    "mastering_purpose": request.mastering_purpose
                },
                "structure": structure,
                "samples": selected_samples,
                "mastering": mastering_config
            }
            
            exported_files = await self.export_manager.export_complete_project(
                mastered_bytes,
                {
                    "base": base_audio_bytes,
                    "stems": stems_dict,
                    "mixed": mixed_audio
                },
                export_config
            )
            
            # === –§–ò–ù–ê–õ–¨–ù–´–ô –†–ï–ó–£–õ–¨–¢–ê–¢ ===
            generation_time = time.time() - start_time
            
            result = GenerationResult(
                success=True,
                final_path=exported_files.get("final_wav"),
                structure_data=structure,
                used_samples=selected_samples,
                generation_time=generation_time,
                quality_score=0.8,  # –ë–∞–∑–æ–≤–∞—è –æ—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞
                intermediate_files={**self._intermediate_storage, **exported_files}
            )
            
            self.logger.info(f"üéâ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞ {generation_time:.1f}—Å")
            self.logger.info(f"üìÅ –°–æ–∑–¥–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: {len(result.intermediate_files)}")
            
            return result
        
        except Exception as e:
            generation_time = time.time() - start_time
            error_msg = f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}"
            
            self.logger.error(f"‚ùå {error_msg}")
            self.logger.error(f"üîç Traceback: {traceback.format_exc()}")
            
            return GenerationResult(
                success=False,
                generation_time=generation_time,
                error_message=error_msg,
                intermediate_files=self._intermediate_storage
            )
    
    async def _analyze_prompt(self, request: GenerationRequest) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–º–ø—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        metadata = {
            "original_prompt": request.prompt,
            "detected_instruments": [],
            "detected_mood": [],
            "detected_bpm": request.bpm,
            "energy_level": request.energy_level,
            "creativity_factor": request.creativity_factor
        }
        
        prompt_lower = request.prompt.lower()
        
        # –ü–æ–∏—Å–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –≤ –ø—Ä–æ–º–ø—Ç–µ
        instrument_keywords = {
            "808": ["808", "sub", "bass"],
            "kick": ["kick", "drum"],
            "snare": ["snare", "clap"],
            "hihat": ["hihat", "hat"],
            "bell": ["bell", "melody"],
            "piano": ["piano", "keys"],
            "vocal": ["vocal", "voice", "singing"]
        }
        
        for instrument, keywords in instrument_keywords.items():
            if any(keyword in prompt_lower for keyword in keywords):
                metadata["detected_instruments"].append(instrument)
        
        # –ü–æ–∏—Å–∫ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è
        mood_keywords = {
            "dark": ["dark", "noir", "shadow", "black"],
            "aggressive": ["aggressive", "hard", "heavy", "angry"],
            "chill": ["chill", "relax", "calm", "peaceful"],
            "energetic": ["energetic", "high", "intense", "powerful"],
            "melodic": ["melodic", "beautiful", "smooth"]
        }
        
        for mood, keywords in mood_keywords.items():
            if any(keyword in prompt_lower for keyword in keywords):
                metadata["detected_mood"].append(mood)
        
        # –ü–æ–∏—Å–∫ BPM –≤ —Ç–µ–∫—Å—Ç–µ
        if not metadata["detected_bpm"]:
            import re
            bpm_match = re.search(r'(\d{2,3})\s*bpm', prompt_lower)
            if bpm_match:
                metadata["detected_bpm"] = int(bpm_match.group(1))
        
        self.logger.info(f"  üìä –ê–Ω–∞–ª–∏–∑: –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã={metadata['detected_instruments']}, "
                        f"–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–µ={metadata['detected_mood']}")
        
        return metadata
    
    async def _determine_genre(self, request: GenerationRequest, metadata: Dict) -> Dict:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞ —Ç—Ä–µ–∫–∞"""
        if request.genre:
            genre_name = request.genre.lower()
            self.logger.info(f"  üé≠ –ñ–∞–Ω—Ä –∑–∞–¥–∞–Ω: {genre_name}")
        else:
            # –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞
            genre_name = self._detect_genre_from_prompt(request.prompt)
            self.logger.info(f"  üé≠ –ñ–∞–Ω—Ä –æ–ø—Ä–µ–¥–µ–ª–µ–Ω: {genre_name}")
        
        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∂–∞–Ω—Ä–∞
        genre_config = config.get_genre_config(genre_name)
        if not genre_config:
            self.logger.warning(f"  ‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∂–∞–Ω—Ä {genre_name}, –∏—Å–ø–æ–ª—å–∑—É–µ–º trap")
            genre_name = "trap"
            genre_config = config.get_genre_config("trap")
        
        return {
            "name": genre_name,
            "config": genre_config,
            "bpm_range": genre_config.bpm_range,
            "target_bpm": metadata.get("detected_bpm") or 
                         (genre_config.bpm_range[0] + genre_config.bpm_range[1]) // 2
        }
    
    def _detect_genre_from_prompt(self, prompt: str) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∂–∞–Ω—Ä–∞ –∏–∑ –ø—Ä–æ–º–ø—Ç–∞"""
        prompt_lower = prompt.lower()
        
        # –ü—Ä—è–º—ã–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
        for genre in config.GENRE_CONFIGS.keys():
            if genre in prompt_lower:
                return genre
        
        # –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –∂–∞–Ω—Ä–æ–≤
        genre_keywords = {
            "trap": ["808", "dark", "urban", "aggressive"],
            "drill": ["drill", "uk", "sliding"],
            "edm": ["kick", "clap", "lead_synth", "riser", "festival", "chill", "melodic_vocal"],
            "lofi": ["chill", "vintage", "cozy", "study"],
            "dnb": ["dnb", "drum", "bass", "jungle", "neurofunk", "liquid"],
            "house": ["house", "dance", "groove", "disco"],
            "techno": ["techno", "industrial", "warehouse"],
            "cinematic": ["cinematic", "epic", "orchestral", "trailer", "heroic"],
            "ambient": ["ambient", "spacious", "meditation", "peaceful", "ethereal"]
        }
        
        # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
        genre_scores = {}
        for genre, keywords in genre_keywords.items():
            score = sum(1 for keyword in keywords if keyword in prompt_lower)
            if score > 0:
                genre_scores[genre] = score
        
        if genre_scores:
            best_genre = max(genre_scores, key=genre_scores.get)
            return best_genre
        
        return "trap"  # –î–µ—Ñ–æ–ª—Ç–Ω—ã–π –∂–∞–Ω—Ä
    
    async def _generate_structure(self, request: GenerationRequest, genre_info: Dict) -> Dict:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ç—Ä–µ–∫–∞"""
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ—Ç LLama3-music
            self.logger.info("  üß† –ó–∞–ø—Ä–æ—Å –∫ LLama3-music")
            llama_structure = self.llama_client.query_structured_music(request.prompt)
            
            if llama_structure and self._validate_llama_structure(llama_structure):
                self.logger.info("  ‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç LLama3-music –ø–æ–ª—É—á–µ–Ω–∞")
                return {
                    "sections": llama_structure["structure"],
                    "total_duration": sum(s["duration"] for s in llama_structure["structure"]),
                    "bpm": llama_structure["bpm"],
                    "source": "llama3-music"
                }
        
        except Exception as e:
            self.logger.warning(f"  ‚ö†Ô∏è LLama3-music –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞: {e}")
        
        # Fallback - —Å–æ–∑–¥–∞–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –Ω–∞ –æ—Å–Ω–æ–≤–µ –∂–∞–Ω—Ä–∞
        self.logger.info("  üèóÔ∏è –°–æ–∑–¥–∞–µ–º fallback —Å—Ç—Ä—É–∫—Ç—É—Ä—É")
        fallback_structure = self._create_fallback_structure(genre_info, request.duration)
        
        return fallback_structure
    
    def _validate_llama_structure(self, structure: Dict) -> bool:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –æ—Ç LLama"""
        if not isinstance(structure, dict):
            return False
        
        if "structure" not in structure or not isinstance(structure["structure"], list):
            return False
        
        if len(structure["structure"]) == 0:
            return False
        
        for section in structure["structure"]:
            if not isinstance(section, dict):
                return False
            if "type" not in section or "duration" not in section:
                return False
        
        return True
    
    def _create_fallback_structure(self, genre_info: Dict, duration: Optional[int]) -> Dict:
        """–°–æ–∑–¥–∞–Ω–∏–µ fallback —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"""
        genre_config = genre_info["config"]
        target_duration = duration or 80
        
        # –ë–µ—Ä–µ–º –±–∞–∑–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∂–∞–Ω—Ä–∞
        base_structure = genre_config.default_structure
        if not base_structure:
            # –°–æ–∑–¥–∞–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
            base_structure = [
                {"type": "intro", "duration": 8, "energy": 0.3},
                {"type": "verse", "duration": 16, "energy": 0.5},
                {"type": "hook", "duration": 16, "energy": 0.8},
                {"type": "verse", "duration": 16, "energy": 0.6},
                {"type": "hook", "duration": 16, "energy": 0.9},
                {"type": "outro", "duration": 8, "energy": 0.4}
            ]
        
        # –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –ø–æ–¥ –Ω—É–∂–Ω—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        current_duration = sum(s["duration"] for s in base_structure)
        scale_factor = target_duration / current_duration if current_duration > 0 else 1.0
        
        scaled_structure = []
        for section in base_structure:
            scaled_section = section.copy()
            scaled_section["duration"] = max(4, int(section["duration"] * scale_factor))
            scaled_structure.append(scaled_section)
        
        total_duration = sum(s["duration"] for s in scaled_structure)
        
        return {
            "sections": scaled_structure,
            "total_duration": total_duration,
            "bpm": genre_info["target_bpm"],
            "source": "fallback"
        }
    
    async def _generate_base_track(
        self, request: GenerationRequest, structure: Dict, genre_info: Dict
    ) -> bytes:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –±–∞–∑–æ–≤–æ–π –¥–æ—Ä–æ–∂–∫–∏ —á–µ—Ä–µ–∑ MusicGen"""
        # –°–æ–∑–¥–∞–µ–º —É–ª—É—á—à–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç
        enhanced_prompt = self._create_enhanced_prompt(request.prompt, genre_info)
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º
        duration = min(structure["total_duration"], 30)  # MusicGen –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ
        
        base_audio = await self.musicgen_engine.generate(
            prompt=enhanced_prompt,
            duration=duration,
            temperature=request.creativity_factor,
            genre_hint=genre_info["name"]
        )
        
        self.logger.info(f"  üéº –ë–∞–∑–æ–≤–∞—è –¥–æ—Ä–æ–∂–∫–∞: {len(base_audio)} bytes")
        return base_audio
    
    def _create_enhanced_prompt(self, original_prompt: str, genre_info: Dict) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è MusicGen"""
        genre = genre_info["name"]
        bpm = genre_info["target_bpm"]
        
        # –ñ–∞–Ω—Ä–æ–≤—ã–µ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è
        genre_additions = {
            "trap": "heavy 808 bass, tight snares, dark urban atmosphere",
            "drill": "uk drill style, sliding 808s, aggressive hi-hats", 
            "lofi": "warm analog sound, vintage vinyl texture, chill vibes",
            "dnb": "fast breakbeats, heavy reese bass, liquid atmosphere",
            "house": "four-on-the-floor groove, deep bassline, danceable",
            "cinematic": "epic orchestral arrangement, trailer music style",
            "ambient": "ethereal pads, spacious reverb, peaceful meditation"
        }
        
        addition = genre_additions.get(genre, "professional music production")
        enhanced = f"{original_prompt}, {addition}, {bpm} bpm, {genre} style"
        
        return enhanced
    
    async def _select_samples(
        self, request: GenerationRequest, structure: Dict, genre_info: Dict
    ) -> List[Dict]:
        """–ü–æ–¥–±–æ—Ä —Å—ç–º–ø–ª–æ–≤ –¥–ª—è —Ç—Ä–µ–∫–∞"""
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω—É–∂–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        required_instruments = genre_info["config"].core_instruments[:3]  # –¢–æ–ø-3
        
        # –°–æ–∑–¥–∞–µ–º —Ç–µ–≥–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞
        search_tags = [genre_info["name"]]
        if hasattr(request, 'prompt'):
            search_tags.extend(request.prompt.lower().split()[:5])  # –ü–µ—Ä–≤—ã–µ 5 —Å–ª–æ–≤
        
        # –ò—â–µ–º —Å—ç–º–ø–ª—ã
        selected_samples = await self.sample_engine.find_samples(
            tags=search_tags,
            instruments=required_instruments,
            genre=genre_info["name"],
            bpm=genre_info["target_bpm"],
            energy=request.energy_level,
            max_results=6
        )
        
        self.logger.info(f"  üéõÔ∏è –ü–æ–¥–æ–±—Ä–∞–Ω–æ —Å—ç–º–ø–ª–æ–≤: {len(selected_samples)}")
        return selected_samples
    
    async def _create_stems(
        self, selected_samples: List[Dict], structure: Dict, genre_info: Dict
    ) -> Dict[str, bytes]:
        """–°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–º–æ–≤ –∏–∑ —Å—ç–º–ø–ª–æ–≤"""
        stems = {}
        total_duration_ms = int(structure["total_duration"] * 1000)
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Å—ç–º–ø–ª—ã –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º
        instrument_groups = {}
        for sample in selected_samples:
            instrument = sample.get("instrument_role", "lead")
            if instrument not in instrument_groups:
                instrument_groups[instrument] = []
            instrument_groups[instrument].append(sample)
        
        # –°–æ–∑–¥–∞–µ–º —Å—Ç–µ–º—ã
        for instrument, samples in instrument_groups.items():
            try:
                stem_audio = await self._create_instrument_stem(
                    samples, total_duration_ms, genre_info
                )
                stems[instrument] = stem_audio
                self.logger.debug(f"    ‚úÖ –°—Ç–µ–º '{instrument}': {len(stem_audio)} bytes")
            
            except Exception as e:
                self.logger.warning(f"    ‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Ç–µ–º–∞ {instrument}: {e}")
        
        if not stems:
            # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –§–ò–ö–°: –°–æ–∑–¥–∞–µ–º —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–º
            self.logger.info("  üîÑ –°–æ–∑–¥–∞–µ–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π —Ä–∏—Ç–º")
            try:
                synthetic_rhythm = self._create_synthetic_rhythm(total_duration_ms, genre_info)
                stems["synthetic_rhythm"] = synthetic_rhythm
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∏—Ç–º–∞: {e}")
                # –í –∫—Ä–∞–π–Ω–µ–º —Å–ª—É—á–∞–µ —Å–æ–∑–¥–∞–µ–º —Ç–∏—à–∏–Ω—É
                silence = AudioSegment.silent(duration=total_duration_ms)
                buffer = io.BytesIO()
                silence.export(buffer, format="wav")
                stems["silence"] = buffer.getvalue()
                buffer.close()
        
        return stems
    
    async def _create_instrument_stem(
        self,
        samples: List[Dict],
        duration_ms: int,
        genre_info: Dict
    ) -> bytes:
        """–°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–º–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""
        try:
            if samples and samples[0].get("path") and os.path.exists(samples[0]["path"]):
                sample_path = samples[0]["path"]
                base_sample = AudioSegment.from_file(sample_path)

                # –ü–æ–≤—Ç–æ—Ä—è–µ–º —Å—ç–º–ø–ª –Ω–∞ –≤—Å—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
                if len(base_sample) < duration_ms:
                    repetitions = (duration_ms // len(base_sample)) + 1
                    repeated = base_sample * repetitions
                    stem_audio = repeated[:duration_ms]
                else:
                    stem_audio = base_sample[:duration_ms]
            else:
                # –°–æ–∑–¥–∞–µ–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–º
                stem_audio = self._create_synthetic_rhythm(duration_ms, genre_info)

            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ bytes
            buffer = io.BytesIO()
            stem_audio.export(buffer, format="wav")
            return buffer.getvalue()

        except Exception as e:
            self.logger.warning(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ —Å—Ç–µ–º–∞: {e}")
            silence = AudioSegment.silent(duration=duration_ms)
            buffer = io.BytesIO()
            silence.export(buffer, format="wav")
            return buffer.getvalue()
    
    def _try_ollama_subprocess(self, prompt: str) -> Optional[Dict]:
        """Fallback —á–µ—Ä–µ–∑ subprocess"""
        system_prompt = """JSON —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç—Ä–µ–∫–∞:
{
  "bpm": —á–∏—Å–ª–æ,
  "structure": [{"type": "intro", "duration": 8}]
}"""
        
        for model in self.ollama_models:
            try:
                self.logger.info(f"  üîÑ Subprocess {model}")
                
                result = subprocess.run(
                    ['ollama', 'run', model],
                    input=f"{system_prompt}\n\n–¢—Ä–µ–∫: {prompt}",
                    capture_output=True,
                    text=True,
                    timeout=90
                )
                
                if result.returncode == 0:
                    parsed = self._parse_json_response(result.stdout)
                    if parsed:
                        self.logger.info(f"  ‚úÖ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç {model}")
                        return parsed
                
            except Exception as e:
                self.logger.warning(f"  ‚ö†Ô∏è Subprocess –æ—à–∏–±–∫–∞: {e}")
                continue
        
        return None
    
    def _parse_json_response(self, raw_output: str) -> Optional[Dict]:
        """–ü–∞—Ä—Å–∏–Ω–≥ JSON –∏–∑ –æ—Ç–≤–µ—Ç–∞"""
        try:
            # –ò—â–µ–º JSON –±–ª–æ–∫
            start = raw_output.find('{')
            end = raw_output.rfind('}')
            
            if start != -1 and end > start:
                json_str = raw_output[start:end+1]
                
                # –û—á–∏—â–∞–µ–º –æ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
                lines = []
                for line in json_str.split('\n'):
                    if not line.strip().startswith('//'):
                        lines.append(line)
                
                clean_json = '\n'.join(lines)
                
                # –£–±–∏—Ä–∞–µ–º trailing commas
                import re
                clean_json = re.sub(r',(\s*[}\]])', r'\1', clean_json)
                
                data = json.loads(clean_json)
                
                # –í–∞–ª–∏–¥–∞—Ü–∏—è
                if self._validate_structure(data):
                    return self._normalize_structure(data)
        
        except Exception as e:
            self.logger.debug(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON: {e}")
        
        return None
    
    def _validate_structure(self, data: Dict) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"""
        if not isinstance(data, dict):
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º bpm
        bpm_val = data.get("bpm", data.get("tempo", 120))
        if not isinstance(bpm_val, (int, float)) or not (60 <= bpm_val <= 200):
            return False
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º structure
        structure = data.get("structure", [])
        if not isinstance(structure, list) or len(structure) == 0:
            return False
        
        for section in structure:
            if not isinstance(section, dict):
                return False
            if "type" not in section or "duration" not in section:
                return False
        
        return True
    
    def _normalize_structure(self, data: Dict) -> Dict:
        """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã"""
        normalized = {
            "bpm": int(data.get("bmp", data.get("tempo", 120))),  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
            "structure": []
        }
        
        for section in data.get("structure", []):
            normalized_section = {
                "type": section.get("type", "section").lower(),
                "duration": max(4, int(section.get("duration", 16))),
                "energy": section.get("energy", 0.5)
            }
            normalized["structure"].append(normalized_section)
        
        return normalized

# ============================================================================
# MUSICGEN –î–í–ò–ñ–û–ö (–°–¢–ê–ë–ò–õ–¨–ù–´–ô)
# ============================================================================

class MusicGenEngine:
    """–°—Ç–∞–±–∏–ª—å–Ω–∞—è –æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è MusicGen"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.model = None
        self.device = "cuda" if torch.cuda.is_available() else "cpu"
        self._load_model()
    
    def _load_model(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ MusicGen –º–æ–¥–µ–ª–∏"""
        if not MUSICGEN_AVAILABLE:
            self.logger.error("‚ùå MusicGen –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω")
            return
        
        try:
            model_paths = [
                config.MUSICGEN_MODEL_PATH,
                "facebook/musicgen-medium",
                "facebook/musicgen-small"
            ]
            
            for path in model_paths:
                try:
                    self.logger.info(f"üéº –ó–∞–≥—Ä—É–∂–∞–µ–º MusicGen: {path}")
                    self.model = musicgen.MusicGen.get_pretrained(path)
                    self.model.set_generation_params(duration=8)
                    self.logger.info(f"‚úÖ MusicGen –∑–∞–≥—Ä—É–∂–µ–Ω: {path}")
                    return
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å {path}: {e}")
                    continue
            
            self.logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –Ω–∏ –æ–¥–Ω—É –º–æ–¥–µ–ª—å MusicGen")
        
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ MusicGen: {e}")
    
    async def generate(
        self,
        prompt: str,
        duration: int = 30,
        temperature: float = 1.0,
        genre_hint: Optional[str] = None
    ) -> bytes:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ —á–µ—Ä–µ–∑ MusicGen"""
        if not self.model:
            self.logger.error("‚ùå MusicGen –º–æ–¥–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            return self._generate_fallback_audio(duration)
        
        try:
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
            safe_duration = min(duration, 30)
            
            self.model.set_generation_params(
                duration=safe_duration,
                use_sampling=True,
                temperature=temperature,
                top_k=250,
                top_p=0.0
            )
            
            # –£–ª—É—á—à–∞–µ–º –ø—Ä–æ–º–ø—Ç
            enhanced_prompt = self._enhance_prompt(prompt, genre_hint)
            self.logger.info(f"üéº –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º: {enhanced_prompt} ({safe_duration}—Å)")
            
            with torch.no_grad():
                wav_tensor = self.model.generate([enhanced_prompt])
            
            if wav_tensor is None or wav_tensor.size(0) == 0:
                raise RuntimeError("MusicGen –≤–µ—Ä–Ω—É–ª –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç")
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–Ω–∑–æ—Ä–∞
            if wav_tensor.dim() == 3:
                audio_array = wav_tensor[0].cpu().numpy()
            elif wav_tensor.dim() == 2:
                audio_array = wav_tensor.cpu().numpy()
            else:
                raise ValueError(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ç–µ–Ω–∑–æ—Ä–∞: {wav_tensor.shape}")
            
            # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
            if audio_array.max() > 1.0 or audio_array.min() < -1.0:
                audio_array = audio_array / max(abs(audio_array.max()), abs(audio_array.min()))
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ç–∏—à–∏–Ω—É
            rms = np.sqrt(np.mean(audio_array**2))
            if rms < 1e-6:
                self.logger.warning("‚ö†Ô∏è –û—á–µ–Ω—å —Ç–∏—Ö–∏–π —Å–∏–≥–Ω–∞–ª, —É—Å–∏–ª–∏–≤–∞–µ–º")
                audio_array = audio_array * 1000
                audio_array = np.clip(audio_array, -1.0, 1.0)
            
            # –≠–∫—Å–ø–æ—Ä—Ç –≤ WAV
            sample_rate = self.model.sample_rate
            buffer = io.BytesIO()
            
            if audio_array.ndim == 1:
                sf.write(buffer, audio_array, sample_rate, format='WAV')
            else:
                if audio_array.shape[0] == 2:
                    sf.write(buffer, audio_array.T, sample_rate, format='WAV')
                else:
                    sf.write(buffer, audio_array[0], sample_rate, format='WAV')
            
            audio_bytes = buffer.getvalue()
            buffer.close()
            
            if len(audio_bytes) < 1000:
                raise RuntimeError(f"–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–π —Ñ–∞–π–ª: {len(audio_bytes)} bytes")
            
            self.logger.info(f"‚úÖ MusicGen —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª: {len(audio_bytes)} bytes")
            return audio_bytes
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ MusicGen: {e}")
            return self._generate_fallback_audio(duration)
    
    def _enhance_prompt(self, prompt: str, genre: Optional[str]) -> str:
        """–£–ª—É—á—à–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è –∂–∞–Ω—Ä–∞"""
        if not genre:
            return prompt
        
        enhancements = {
            "trap": "heavy 808s, tight snares, dark atmosphere",
            "lofi": "warm analog sound, vinyl texture, mellow vibes",
            "dnb": "fast breakbeats, heavy bass, energetic",
            "drill": "uk drill, sliding 808s, aggressive hi-hats",
            "cinematic": "epic orchestral, trailer music, heroic",
            "ambient": "ethereal pads, spacious reverb, peaceful"
        }
        
        enhancement = enhancements.get(genre, "")
        if enhancement:
            return f"{prompt}, {enhancement}"
        
        return prompt
    
    def _generate_fallback_audio(self, duration: int) -> bytes:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è fallback –∞—É–¥–∏–æ"""
        self.logger.warning("üîÑ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º fallback –∞—É–¥–∏–æ")
        
        try:
            sample_rate = 44100
            t = np.linspace(0, duration, int(sample_rate * duration))
            
            # –°–æ–∑–¥–∞—ë–º –ø—Ä–æ—Å—Ç–æ–π –º–∏–∫—Å
            noise = np.random.normal(0, 0.05, len(t))
            bass = np.sin(2 * np.pi * 60 * t) * 0.2
            mid = np.sin(2 * np.pi * 220 * t) * 0.1
            
            audio_array = (noise + bass + mid) * 0.8
            
            buffer = io.BytesIO()
            sf.write(buffer, audio_array, sample_rate, format='WAV')
            return buffer.getvalue()
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ fallback –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
            # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ç–∏—à–∏–Ω–∞
            silence = np.zeros(int(44100 * duration))
            buffer = io.BytesIO()
            sf.write(buffer, silence, 44100, format='WAV')
            return buffer.getvalue()

# ============================================================================
# –°–ï–ú–ê–ù–¢–ò–ß–ï–°–ö–ò–ô –ü–û–ò–°–ö –°–≠–ú–ü–õ–û–í (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô - –í–°–ï–ì–î–ê –ù–ê–•–û–î–ò–¢ –ß–¢–û-–¢–û)
# ============================================================================

class SimpleSemanticEngine:
    """–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –≤–µ—Ä—Å–∏—è —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞ - –í–°–ï–ì–î–ê –Ω–∞–π–¥–µ—Ç —Å—ç–º–ø–ª—ã –∏–ª–∏ —Å–æ–∑–¥–∞—Å—Ç —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ"""
    
    def __init__(self, sample_dir: str = None):
        self.sample_dir = sample_dir or config.DEFAULT_SAMPLE_DIR
        self.logger = logging.getLogger(__name__)
        self.samples_index: List[SampleMetadata] = []
        self.semantic_model = None
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–π –º–æ–¥–µ–ª–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        if SEMANTIC_AVAILABLE:
            try:
                self.semantic_model = SentenceTransformer('all-MiniLM-L6-v2')
                self.logger.info("‚úÖ –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∞—è –º–æ–¥–µ–ª—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞: {e}")
        
        # –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–µ–∫—Å
        self.load_or_build_index()
        
        # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –§–ò–ö–°: –ï—Å–ª–∏ –∏–Ω–¥–µ–∫—Å –ø—É—Å—Ç, —Å–æ–∑–¥–∞–µ–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ —Å—ç–º–ø–ª—ã
        if not self.samples_index:
            self.logger.warning("‚ö†Ô∏è –ò–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤ –ø—É—Å—Ç, —Å–æ–∑–¥–∞–µ–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ —Å—ç–º–ø–ª—ã –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏")
            self._create_synthetic_sample_index()
    
    def _create_synthetic_sample_index(self):
        """–ù–û–í–´–ô –ú–ï–¢–û–î: –°–æ–∑–¥–∞–Ω–∏–µ —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö —Å—ç–º–ø–ª–æ–≤ –µ—Å–ª–∏ —Ä–µ–∞–ª—å–Ω—ã—Ö –Ω–µ—Ç"""
        synthetic_samples = [
            SampleMetadata(
                path="synthetic://kick.wav",
                filename="synthetic_kick.wav",
                duration=1.0,
                tempo=120,
                key="C",
                tags=["kick", "synthetic", "demo"],
                genres=["trap", "hip-hop"],
                instrument_role="kick",
                quality_score=0.8,
                energy_level=0.7
            ),
            SampleMetadata(
                path="synthetic://snare.wav", 
                filename="synthetic_snare.wav",
                duration=0.8,
                tempo=120,
                key="D",
                tags=["snare", "synthetic", "demo"],
                genres=["trap", "hip-hop"],
                instrument_role="snare",
                quality_score=0.8,
                energy_level=0.8
            ),
            SampleMetadata(
                path="synthetic://hihat.wav",
                filename="synthetic_hihat.wav", 
                duration=0.3,
                tempo=120,
                key="F",
                tags=["hihat", "synthetic", "demo"],
                genres=["trap", "hip-hop"],
                instrument_role="hihat",
                quality_score=0.7,
                energy_level=0.6
            ),
            SampleMetadata(
                path="synthetic://808.wav",
                filename="synthetic_808.wav",
                duration=2.0,
                tempo=120,
                key="C",
                tags=["808", "bass", "synthetic", "demo"],
                genres=["trap", "drill"],
                instrument_role="bass",
                quality_score=0.9,
                energy_level=0.8
            ),
            SampleMetadata(
                path="synthetic://melody.wav",
                filename="synthetic_melody.wav",
                duration=4.0,
                tempo=120,
                key="Am",
                tags=["melody", "lead", "synthetic", "demo"],
                genres=["trap", "lofi"],
                instrument_role="lead",
                quality_score=0.7,
                energy_level=0.5
            )
        ]
        
        self.samples_index = synthetic_samples
        self.logger.info(f"‚úÖ –°–æ–∑–¥–∞–Ω–æ {len(synthetic_samples)} —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏—Ö —Å—ç–º–ø–ª–æ–≤ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏")
    
    def load_or_build_index(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞"""
        index_path = Path(self.sample_dir) / config.INDEX_FILE
        
        if index_path.exists():
            self.logger.info(f"üìÇ –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω–¥–µ–∫—Å: {index_path}")
            try:
                with open(index_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                self.samples_index = []
                for item in data:
                    metadata = SampleMetadata(
                        path=item.get("path", ""),
                        filename=item.get("filename", ""),
                        duration=item.get("duration", 0.0),
                        tempo=item.get("tempo", 120),
                        key=item.get("key"),
                        tags=item.get("tags", []),
                        genres=item.get("genres", []),
                        instrument_role=item.get("instrument_role"),
                        quality_score=item.get("quality_score", 0.6),
                        energy_level=item.get("energy_level", 0.5)
                    )
                    self.samples_index.append(metadata)
                
                self.logger.info(f"‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(self.samples_index)} —Å—ç–º–ø–ª–æ–≤")
            
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–Ω–¥–µ–∫—Å–∞: {e}")
                self.build_simple_index()
        else:
            self.logger.info("üî® –°—Ç—Ä–æ–∏–º –Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤")
            self.build_simple_index()
    
    def build_simple_index(self):
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è"""
        self.logger.info("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—ç–º–ø–ª—ã...")
        
        # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π JSON –∏–Ω–¥–µ–∫—Å –∏–∑ –≤–∞—à–µ–π –±–∞–∑—ã
        existing_json_files = [
            "sample_index.json",
            "enhanced_sample_index.json", 
            "samples.json"
        ]
        
        for json_file in existing_json_files:
            json_path = Path(self.sample_dir) / json_file
            if json_path.exists():
                self.logger.info(f"üìã –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∏–Ω–¥–µ–∫—Å: {json_file}")
                try:
                    with open(json_path, 'r', encoding='utf-8') as f:
                        existing_data = json.load(f)
                    
                    if isinstance(existing_data, list):
                        self._convert_existing_index(existing_data)
                        self.save_index()
                        return
                except Exception as e:
                    self.logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å {json_file}: {e}")
        
        # –ï—Å–ª–∏ –Ω–µ—Ç –≥–æ—Ç–æ–≤–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞, —Å–∫–∞–Ω–∏—Ä—É–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
        self._scan_directory()
        self.save_index()
    
    def _convert_existing_index(self, existing_data: List[Dict]):
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç"""
        self.samples_index = []
        
        for item in existing_data:
            # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å –º–∞–∫—Å–∏–º—É–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
            metadata = SampleMetadata(
                path=item.get("path", ""),
                filename=item.get("filename", ""),
                duration=float(item.get("duration", 0)),
                tempo=int(item.get("tempo", 120)),
                key=item.get("key"),
                tags=item.get("tags", []),
                genres=item.get("genres", []),
                instrument_role=item.get("instrument_role"),
                quality_score=float(item.get("quality_score", 0.6)),
                energy_level=float(item.get("energy_level", 1.0 if "energetic" in item.get("tags", []) else 0.5))
            )
            
            # –ï—Å–ª–∏ –ø—É—Ç—å –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π, –¥–µ–ª–∞–µ–º –∞–±—Å–æ–ª—é—Ç–Ω—ã–º
            if not os.path.isabs(metadata.path):
                metadata.path = os.path.join(self.sample_dir, metadata.path)
            
            self.samples_index.append(metadata)
        
        self.logger.info(f"üîÑ –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ {len(self.samples_index)} —Å—ç–º–ø–ª–æ–≤")
    
    def _scan_directory(self):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å—ç–º–ø–ª–æ–≤"""
        self.samples_index = []
        processed = 0
        
        for root, _, files in os.walk(self.sample_dir):
            for file in files:
                if file.lower().endswith(('.wav', '.mp3', '.aiff', '.flac')):
                    full_path = os.path.join(root, file)
                    
                    try:
                        # –ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ —Ñ–∞–π–ª–∞
                        metadata = self._quick_analyze_sample(full_path, file)
                        if metadata:
                            self.samples_index.append(metadata)
                            processed += 1
                            
                            if processed % 100 == 0:
                                self.logger.info(f"  üìä –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {processed} —Ñ–∞–π–ª–æ–≤")
                    
                    except Exception as e:
                        self.logger.debug(f"‚ö†Ô∏è –ü—Ä–æ–ø—É—Å–∫–∞–µ–º {file}: {e}")
        
        self.logger.info(f"üéØ –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: {len(self.samples_index)} —Å—ç–º–ø–ª–æ–≤")
    
    def _quick_analyze_sample(self, full_path: str, filename: str) -> Optional[SampleMetadata]:
        """–ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ —Å—ç–º–ø–ª–∞"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
            try:
                audio = AudioSegment.from_file(full_path)
                duration = len(audio) / 1000.0
            except:
                # Fallback —á–µ—Ä–µ–∑ librosa
                y, sr = librosa.load(full_path, duration=10)
                duration = len(y) / sr
            
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–µ/–¥–ª–∏–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
            if duration < 0.5 or duration > 300:
                return None
            
            # –ê–Ω–∞–ª–∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
            tags, bpm, key = self._analyze_filename(filename)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∂–∞–Ω—Ä –∏–∑ –ø—É—Ç–∏
            path_lower = full_path.lower()
            genres = []
            genre_keywords = {
                "trap": ["trap", "drill"],
                "lofi": ["lofi", "chill"],
                "dnb": ["dnb", "drum", "bass", "jungle"],
                "house": ["house", "tech"],
                "ambient": ["ambient", "pad"],
                "cinematic": ["cinematic", "epic", "trailer"]
            }
            
            for genre, keywords in genre_keywords.items():
                if any(keyword in path_lower for keyword in keywords):
                    genres.append(genre)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–æ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
            instrument_role = self._detect_instrument(filename, tags)
            
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —ç–Ω–µ—Ä–≥–∏—é –∏–∑ —Ç–µ–≥–æ–≤
            energy_level = 1.0 if "energetic" in tags else 0.5
            if any(tag in tags for tag in ["dark", "aggressive", "heavy"]):
                energy_level = min(1.0, energy_level + 0.2)
            if any(tag in tags for tag in ["calm", "soft", "chill"]):
                energy_level = max(0.1, energy_level - 0.3)
            
            return SampleMetadata(
                path=full_path,
                filename=filename,
                duration=round(duration, 2),
                tempo=bpm,
                key=key,
                tags=tags,
                genres=genres,
                instrument_role=instrument_role,
                quality_score=0.6,
                energy_level=energy_level
            )
        
        except Exception as e:
            self.logger.debug(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {filename}: {e}")
            return None
    
    def _analyze_filename(self, filename: str) -> Tuple[List[str], int, Optional[str]]:
        """–ê–Ω–∞–ª–∏–∑ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        name_lower = filename.lower()
        tags = []
        bpm = 120
        key = None
        
        # –ü–æ–∏—Å–∫ BPM
        import re
        bpm_patterns = [r'(\d{2,3})\s*bpm', r'(\d{2,3})\s*beats', r'bpm\s*(\d{2,3})']
        for pattern in bpm_patterns:
            match = re.search(pattern, name_lower)
            if match:
                found_bpm = int(match.group(1))
                if 60 <= found_bpm <= 200:
                    bpm = found_bpm
                break
        
        # –ü–æ–∏—Å–∫ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
        key_patterns = [r'([a-g][#b]?)\s*(?:maj|min|major|minor)', r'key\s*([a-g][#b]?)']
        for pattern in key_patterns:
            match = re.search(pattern, name_lower)
            if match:
                key = match.group(1).upper()
                break
        
        # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–µ–≥–æ–≤ –∏–∑ –∏–º–µ–Ω–∏
        tag_keywords = {
            "energetic": ["energetic", "energy", "high", "intense"],
            "dark": ["dark", "noir", "shadow", "black"],
            "aggressive": ["aggressive", "hard", "heavy", "punch"],
            "chill": ["chill", "relax", "calm", "soft"],
            "melodic": ["melodic", "melody", "tune"],
            "complex": ["complex", "detailed", "rich"]
        }
        
        for tag, keywords in tag_keywords.items():
            if any(keyword in name_lower for keyword in keywords):
                tags.append(tag)
        
        return tags, bpm, key
    
    def _detect_instrument(self, filename: str, tags: List[str]) -> Optional[str]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""
        name_lower = filename.lower()
        
        # –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
        instrument_keywords = {
            "kick": ["kick", "bd", "bassdrum"],
            "snare": ["snare", "sd", "snap"],
            "hihat": ["hihat", "hh", "hat"],
            "bass": ["bass", "sub", "808"],
            "lead": ["lead", "melody", "synth"],
            "pad": ["pad", "chord", "string"],
            "vocal": ["vocal", "voice", "vox"],
            "fx": ["fx", "effect", "riser", "sweep"]
        }
        
        for instrument, keywords in instrument_keywords.items():
            if any(keyword in name_lower for keyword in keywords):
                return instrument
        
        return "lead"  # –î–µ—Ñ–æ–ª—Ç
    
    def save_index(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–Ω–¥–µ–∫—Å–∞"""
        index_path = Path(self.sample_dir) / config.INDEX_FILE
        
        try:
            index_data = []
            for sample in self.samples_index:
                item = {
                    "path": sample.path,
                    "filename": sample.filename,
                    "duration": sample.duration,
                    "tempo": sample.tempo,
                    "key": sample.key,
                    "tags": sample.tags,
                    "genres": sample.genres,
                    "instrument_role": sample.instrument_role,
                    "quality_score": sample.quality_score,
                    "energy_level": sample.energy_level
                }
                index_data.append(item)
            
            with open(index_path, 'w', encoding='utf-8') as f:
                json.dump(index_data, f, indent=2, ensure_ascii=False)
            
            self.logger.info(f"üíæ –ò–Ω–¥–µ–∫—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {len(index_data)} —Å—ç–º–ø–ª–æ–≤")
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω–¥–µ–∫—Å–∞: {e}")
    
    async def find_samples(
        self,
        tags: List[str],
        instruments: Optional[List[str]] = None,
        genre: Optional[str] = None,
        bpm: Optional[int] = None,
        energy: float = 0.5,
        max_results: int = 10
    ) -> List[Dict]:
        """–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ø–æ–∏—Å–∫ —Å—ç–º–ø–ª–æ–≤ - –í–°–ï–ì–î–ê –Ω–∞–π–¥–µ—Ç —á—Ç–æ-—Ç–æ"""
        self.logger.info(f"üîç –ü–æ–∏—Å–∫ —Å—ç–º–ø–ª–æ–≤: —Ç–µ–≥–∏={tags}, –∂–∞–Ω—Ä={genre}, BPM={bpm}")
        
        # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –§–ò–ö–°: –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å—ç–º–ø–ª—ã –≤ –∏–Ω–¥–µ–∫—Å–µ
        if not self.samples_index:
            self.logger.warning("‚ö†Ô∏è –ò–Ω–¥–µ–∫—Å —Å—ç–º–ø–ª–æ–≤ –ø—É—Å—Ç, —Å–æ–∑–¥–∞–µ–º —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ")
            self._create_synthetic_sample_index()
        
        candidates = []
        
        for sample in self.samples_index:
            score = self._calculate_sample_score(sample, tags, instruments, genre, bpm, energy)
            
            if score > 0.1:  # –ü–û–ù–ò–ñ–ï–ù –ø–æ—Ä–æ–≥ —Å 0.3 –¥–æ 0.1 —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –±–æ–ª—å—à–µ
                candidates.append({
                    "metadata": sample,
                    "score": score,
                    "path": sample.path,
                    "filename": sample.filename,
                    "instrument_role": sample.instrument_role,
                    "tags": sample.tags,
                    "tempo": sample.tempo,
                    "quality_score": sample.quality_score,
                    "energy_level": sample.energy_level
                })
        
        # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –§–ò–ö–°: –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, —Å–æ–∑–¥–∞–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        if not candidates:
            self.logger.warning("‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å—ç–º–ø–ª–æ–≤, —Å–æ–∑–¥–∞–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")
            candidates = self._create_fallback_samples(tags, instruments, genre, bpm, energy)
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–∫–æ—Ä—É
        candidates.sort(key=lambda x: x["score"], reverse=True)
        
        # –î–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        results = self._diversify_results(candidates, max_results)
        
        self.logger.info(f"  ‚úÖ –ù–∞–π–¥–µ–Ω–æ {len(results)} —Å—ç–º–ø–ª–æ–≤")
        return results[:max_results]
    
    def _create_fallback_samples(self, tags, instruments, genre, bpm, energy) -> List[Dict]:
        """–ù–û–í–´–ô –ú–ï–¢–û–î: –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∏–∫—Ç–∏–≤–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞"""
        fallback_samples = []
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω—É–∂–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        target_instruments = instruments or ["kick", "snare", "hihat", "bass"]
        
        for i, instrument in enumerate(target_instruments[:6]):  # –ú–∞–∫—Å–∏–º—É–º 6
            synthetic_sample = {
                "metadata": SampleMetadata(
                    path=f"synthetic://{instrument}_{i}.wav",
                    filename=f"fallback_{instrument}_{i}.wav",
                    duration=1.5,
                    tempo=bpm or 120,
                    key="C",
                    tags=tags or [instrument, "synthetic"],
                    genres=[genre] if genre else ["generic"],
                    instrument_role=instrument,
                    quality_score=0.6,
                    energy_level=energy
                ),
                "score": 0.8 - (i * 0.1),  # –£–º–µ–Ω—å—à–∞–µ–º —Å–∫–æ—Ä –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
                "path": f"synthetic://{instrument}_{i}.wav",
                "filename": f"fallback_{instrument}_{i}.wav",
                "instrument_role": instrument,
                "tags": tags or [instrument, "synthetic"],
                "tempo": bmp or 120,
                "quality_score": 0.6,
                "energy_level": energy
            }
            fallback_samples.append(synthetic_sample)
        
        return fallback_samples
    
    def _calculate_sample_score(
        self, sample: SampleMetadata, tags: List[str], 
        instruments: Optional[List[str]], genre: Optional[str],
        bpm: Optional[int], energy: float
    ) -> float:
        """–†–∞—Å—á–µ—Ç —Å–∫–æ—Ä–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —Å—ç–º–ø–ª–∞"""
        score = 0.0
        
        # 1. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–µ–≥–æ–≤ (30%)
        if tags:
            tag_matches = len(set(tag.lower() for tag in tags) & 
                           set(tag.lower() for tag in sample.tags))
            tag_score = tag_matches / len(tags)
            score += tag_score * 0.3
        
        # 2. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ (25%)
        if instruments and sample.instrument_role:
            if sample.instrument_role in [inst.lower() for inst in instruments]:
                score += 0.25
        
        # 3. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∂–∞–Ω—Ä–∞ (20%)
        if genre and sample.genres:
            if genre.lower() in [g.lower() for g in sample.genres]:
                score += 0.2
            else:
                # –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ
                for sample_genre in sample.genres:
                    if genre.lower() in sample_genre.lower() or sample_genre.lower() in genre.lower():
                        score += 0.1
                        break
        
        # 4. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ BPM (15%)
        if bpm and sample.tempo:
            tempo_diff = abs(sample.tempo - bpm)
            if tempo_diff <= 5:
                score += 0.15
            elif tempo_diff <= 15:
                score += 0.1
            elif tempo_diff <= 30:
                score += 0.05
        
        # 5. –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ (10%)
        energy_diff = abs(sample.energy_level - energy)
        energy_score = max(0, 1 - energy_diff)
        score += energy_score * 0.1
        
        # –ë–æ–Ω—É—Å –∑–∞ –∫–∞—á–µ—Å—Ç–≤–æ
        score += sample.quality_score * 0.1
        
        # –ù–û–í–´–ô –§–ò–ö–°: –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±–∞–∑–æ–≤—ã–π —Å–∫–æ—Ä –¥–ª—è –≤—Å–µ—Ö —Å—ç–º–ø–ª–æ–≤
        score = max(score, 0.15)  # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å–∫–æ—Ä
        
        return min(1.0, score)
    
    def _diversify_results(self, candidates: List[Dict], max_results: int) -> List[Dict]:
        """–î–∏–≤–µ—Ä—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
        if len(candidates) <= max_results:
            return candidates
        
        diversified = []
        used_instruments = set()
        
        # –ü–µ—Ä–≤—ã–π –ø—Ä–æ—Ö–æ–¥ - —Ä–∞–∑–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
        for candidate in candidates:
            if len(diversified) >= max_results:
                break
            
            instrument = candidate.get("instrument_role")
            if instrument not in used_instruments:
                diversified.append(candidate)
                used_instruments.add(instrument)
        
        # –í—Ç–æ—Ä–æ–π –ø—Ä–æ—Ö–æ–¥ - –ª—É—á—à–∏–µ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è
        for candidate in candidates:
            if len(diversified) >= max_results:
                break
            if candidate not in diversified:
                diversified.append(candidate)
        
        return diversified[:max_results]

# ============================================================================
# –°–ò–°–¢–ï–ú–ê –ú–ê–°–¢–ï–†–ò–ù–ì–ê (–°–¢–ê–ë–ò–õ–¨–ù–ê–Ø)
# ============================================================================

class StableMasteringEngine:
    """–°—Ç–∞–±–∏–ª—å–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ –¥–≤–∏–∂–æ–∫ —Å –±–µ–∑–æ–ø–∞—Å–Ω—ã–º–∏ fallback'–∞–º–∏"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    async def master_track(
        self,
        audio_bytes: bytes,
        target_config: Dict,
        genre_info: Dict,
        purpose: str = "personal"
    ) -> Tuple[AudioSegment, Dict]:
        """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞"""
        self.logger.info(f"üéõÔ∏è –ù–∞—á–∏–Ω–∞–µ–º –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ –¥–ª—è {purpose}")
        
        try:
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –∞—É–¥–∏–æ
            audio_segment = self._load_audio_from_bytes(audio_bytes)
            if not audio_segment:
                raise ValueError("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ")
            
            # –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            original_audio = audio_segment
            processed_audio = audio_segment
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –±–∞–∑–æ–≤—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ (–≤—Å–µ–≥–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç)
            processed_audio = await self._apply_basic_mastering(processed_audio, target_config)
            
            # –ü—Ä–æ–±—É–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥
            try:
                enhanced_audio = await self._apply_enhanced_mastering(
                    processed_audio, target_config, genre_info, purpose
                )
                processed_audio = enhanced_audio
                self.logger.info("‚ú® –ü—Ä–∏–º–µ–Ω—ë–Ω —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥")
            
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ –Ω–µ —É–¥–∞–ª—Å—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–π: {e}")
                # processed_audio –æ—Å—Ç–∞–µ—Ç—Å—è —Å –±–∞–∑–æ–≤—ã–º –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–æ–º
            
            # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
            if self._validate_audio(processed_audio):
                self.logger.info("‚úÖ –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥ –∑–∞–≤–µ—Ä—à–µ–Ω —É—Å–ø–µ—à–Ω–æ")
                return processed_audio, target_config
            else:
                self.logger.warning("‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã —Å –∫–∞—á–µ—Å—Ç–≤–æ–º, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—É—é –≤–µ—Ä—Å–∏—é")
                return original_audio, target_config
        
        except Exception as e:
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞: {e}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª –≤ —Å–ª—É—á–∞–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏
            try:
                fallback_audio = self._load_audio_from_bytes(audio_bytes)
                return fallback_audio, target_config
            except:
                # –°–æ–≤—Å–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–∏—Ç—É–∞—Ü–∏—è
                silence = AudioSegment.silent(duration=30000)
                return silence, target_config
    
    def _load_audio_from_bytes(self, audio_bytes: bytes) -> Optional[AudioSegment]:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –∞—É–¥–∏–æ –∏–∑ bytes"""
        try:
            buffer = io.BytesIO(audio_bytes)
            audio = AudioSegment.from_file(buffer, format="wav")
            buffer.close()
            return audio
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞—É–¥–∏–æ: {e}")
            return None
    
    async def _apply_basic_mastering(self, audio: AudioSegment, config: Dict) -> AudioSegment:
        """–ë–∞–∑–æ–≤—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ - –≤—Å–µ–≥–¥–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç"""
        processed = audio
        
        # 1. –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è (–±–µ–∑–æ–ø–∞—Å–Ω–∞—è)
        try:
            processed = normalize(processed, headroom=0.1)
            self.logger.debug("  ‚úì –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∞")
        except Exception as e:
            self.logger.warning(f"–û—à–∏–±–∫–∞ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏: {e}")
        
        # 2. –ü—Ä–æ—Å—Ç–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è
        try:
            if processed.dBFS > -6:
                processed = compress_dynamic_range(processed, threshold=-12, ratio=2.0, attack=5, release=50)
                self.logger.debug("  ‚úì –ö–æ–º–ø—Ä–µ—Å—Å–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∞")
        except Exception as e:
            self.logger.warning(f"–û—à–∏–±–∫–∞ –∫–æ–º–ø—Ä–µ—Å—Å–∏–∏: {e}")
        
        # 3. –õ–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∏–∫–∞
        try:
            peak_ceiling = config.get("peak_ceiling", -1)
            if processed.max_dBFS > peak_ceiling:
                reduction = processed.max_dBFS - peak_ceiling
                processed = processed - reduction
                self.logger.debug(f"  ‚úì –õ–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: -{reduction:.1f}dB")
        except Exception as e:
            self.logger.warning(f"–û—à–∏–±–∫–∞ –ª–∏–º–∏—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
        
        return processed
    
    async def _apply_enhanced_mastering(
        self, audio: AudioSegment, config: Dict, 
        genre_info: Dict, purpose: str
    ) -> AudioSegment:
        """–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ - –º–æ–∂–µ—Ç –ø–∞–¥–∞—Ç—å"""
        processed = audio
        genre = genre_info.get("name", "generic")
        
        # –ñ–∞–Ω—Ä–æ–≤–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        if genre == "trap":
            processed = await self._apply_trap_mastering(processed)
        elif genre == "lofi":
            processed = await self._apply_lofi_mastering(processed)
        elif genre == "dnb":
            processed = await self._apply_dnb_mastering(processed)
        elif genre == "cinematic":
            processed = await self._apply_cinematic_mastering(processed)
        
        # –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥ –ø–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—é
        if purpose == "freelance":
            processed = await self._apply_commercial_mastering(processed)
        elif purpose == "vinyl":
            processed = await self._apply_vinyl_mastering(processed)
        
        return processed
    
    async def _apply_trap_mastering(self, audio: AudioSegment) -> AudioSegment:
        """Trap-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥"""
        processed = audio
        
        # –£—Å–∏–ª–µ–Ω–∏–µ –Ω–∏–∑–∫–∏—Ö —á–∞—Å—Ç–æ—Ç (–∏–º–∏—Ç–∞—Ü–∏—è)
        processed = processed.low_pass_filter(100) + 2 + processed.high_pass_filter(100)
        
        # Aggressive compression –¥–ª—è trap'–∞
        processed = compress_dynamic_range(processed, threshold=-8, ratio=3.5, attack=3, release=30)
        
        return processed
    
    async def _apply_lofi_mastering(self, audio: AudioSegment) -> AudioSegment:
        """Lo-fi —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥"""
        processed = audio
        
        # –í–∏–Ω—Ç–∞–∂–Ω–æ–µ –∑–≤—É—á–∞–Ω–∏–µ - –æ–±—Ä–µ–∑–∞–µ–º –≤—ã—Å–æ–∫–∏–µ —á–∞—Å—Ç–æ—Ç—ã
        processed = processed.low_pass_filter(8000)
        
        # –õ–µ–≥–∫–æ–µ –Ω–∞—Å—ã—â–µ–Ω–∏–µ (–∏–º–∏—Ç–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∫–æ–º–ø—Ä–µ—Å—Å–∏—é)
        processed = compress_dynamic_range(processed, threshold=-15, ratio=1.5, attack=10, release=100)
        
        # –ù–µ–º–Ω–æ–≥–æ —É–±–∏—Ä–∞–µ–º –≥—Ä–æ–º–∫–æ—Å—Ç—å –¥–ª—è "–≤–∏–Ω—Ç–∞–∂–Ω–æ—Å—Ç–∏"
        processed = processed - 2
        
        return processed
    
    async def _apply_dnb_mastering(self, audio: AudioSegment) -> AudioSegment:
        """DNB —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥"""
        processed = audio
        
        # Tight compression –¥–ª—è DNB
        processed = compress_dynamic_range(processed, threshold=-6, ratio=4.0, attack=2, release=20)
        
        # Boost high-end –¥–ª—è —á–µ—Ç–∫–æ—Å—Ç–∏
        high_freq = processed.high_pass_filter(3000) + 1
        low_freq = processed.low_pass_filter(3000)
        processed = low_freq.overlay(high_freq)
        
        return processed
    
    async def _apply_cinematic_mastering(self, audio: AudioSegment) -> AudioSegment:
        """Cinematic –º–∞—Å—Ç–µ—Ä–∏–Ω–≥"""
        processed = audio
        
        # –®–∏—Ä–æ–∫–∏–π –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –¥–∏–∞–ø–∞–∑–æ–Ω - –º—è–≥–∫–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è
        processed = compress_dynamic_range(processed, threshold=-18, ratio=1.5, attack=20, release=200)
        
        # Boost –Ω–∞ –Ω–∏–∑–∫–∏—Ö –¥–ª—è —ç–ø–∏—á–Ω–æ—Å—Ç–∏
        low_boost = processed.low_pass_filter(200) + 1
        rest = processed.high_pass_filter(200)
        processed = low_boost.overlay(rest)
        
        return processed
    
    async def _apply_commercial_mastering(self, audio: AudioSegment) -> AudioSegment:
        """–ö–æ–º–º–µ—Ä—á–µ—Å–∫–∏–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏"""
        processed = audio
        
        # –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è –¥–ª—è –≥—Ä–æ–º–∫–æ—Å—Ç–∏
        processed = compress_dynamic_range(processed, threshold=-10, ratio=3.0, attack=3, release=40)
        
        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫ -14 LUFS (–ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ)
        processed = normalize(processed, headroom=1.0)
        
        return processed
    
    async def _apply_vinyl_mastering(self, audio: AudioSegment) -> AudioSegment:
        """–í–∏–Ω–∏–ª–æ–≤—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥"""
        processed = audio
        
        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —á–∞—Å—Ç–æ—Ç–Ω–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ –¥–ª—è –≤–∏–Ω–∏–ª–∞
        processed = processed.high_pass_filter(30).low_pass_filter(16000)
        
        # –ú—è–≥–∫–∞—è –∫–æ–º–ø—Ä–µ—Å—Å–∏—è
        processed = compress_dynamic_range(processed, threshold=-20, ratio=2.0, attack=15, release=150)
        
        # –°–Ω–∏–∂–µ–Ω–∏–µ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –¥–ª—è –≤–∏–Ω–∏–ª–∞
        processed = processed - 6
        
        return processed
    
    def _validate_audio(self, audio: AudioSegment) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ –∞—É–¥–∏–æ"""
        try:
            if len(audio) < 1000:  # –ú–µ–Ω—å—à–µ 1 —Å–µ–∫—É–Ω–¥—ã
                return False
            if audio.dBFS < -60:  # –°–ª–∏—à–∫–æ–º —Ç–∏—Ö–æ
                return False
            if audio.max_dBFS > -0.1:  # –í–æ–∑–º–æ–∂–Ω—ã–π –∫–ª–∏–ø–ø–∏–Ω–≥
                self.logger.warning("‚ö†Ô∏è –í–æ–∑–º–æ–∂–Ω—ã–π –∫–ª–∏–ø–ø–∏–Ω–≥ –æ–±–Ω–∞—Ä—É–∂–µ–Ω")
            return True
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –∞—É–¥–∏–æ: {e}")
            return False
    
    def _create_synthetic_rhythm(self, duration_ms: int, genre_info: Dict) -> AudioSegment:
        """–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –≤–µ—Ä—Å–∏—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∏—Ç–º–∞ - –ë–ï–ó band_pass_filter"""
        try:
            genre = genre_info["name"]
            bpm = genre_info.get("target_bpm", 120)
            
            # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–∏—Ç–º–∞
            beat_duration = int(60000 / bpm)  # –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –±–∏—Ç–∞ –≤ –º—Å
            bars_needed = (duration_ms // (beat_duration * 4)) + 1
            
            # –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–µ –∑–≤—É–∫–∏
            kick = Sine(60).to_audio_segment(duration=200).apply_gain(-6)
            snare = WhiteNoise().to_audio_segment(duration=150).apply_gain(-10)
            # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –§–ò–ö–°: –∑–∞–º–µ–Ω—è–µ–º band_pass_filter –Ω–∞ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é high_pass + low_pass
            snare = snare.high_pass_filter(200).low_pass_filter(4000)
            hihat = WhiteNoise().to_audio_segment(duration=50).apply_gain(-15)
            hihat = hihat.high_pass_filter(8000)
            
            # –ü–∞—Ç—Ç–µ—Ä–Ω—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∂–∞–Ω—Ä–æ–≤
            patterns = {
                "trap": {
                    "kick": [1, 0, 0, 1, 0, 0, 1, 0],
                    "snare": [0, 0, 1, 0, 0, 0, 1, 0],
                    "hihat": [1, 1, 0, 1, 1, 0, 1, 1]
                },
                "house": {
                    "kick": [1, 0, 0, 0, 1, 0, 0, 0],
                    "snare": [0, 0, 1, 0, 0, 0, 1, 0],
                    "hihat": [0, 1, 0, 1, 0, 1, 0, 1]
                },
                "dnb": {
                    "kick": [1, 0, 0, 0, 0, 1, 0, 0],
                    "snare": [0, 0, 1, 0, 1, 0, 1, 0],
                    "hihat": [1, 0, 1, 1, 0, 1, 0, 1]
                },
                "lofi": {
                    "kick": [1, 0, 0, 0, 1, 0, 0, 0],
                    "snare": [0, 0, 1, 0, 0, 0, 1, 0],
                    "hihat": [0, 1, 0, 0, 0, 1, 0, 0]
                },
                "drill": {
                    "kick": [1, 0, 0, 1, 0, 1, 0, 0],
                    "snare": [0, 0, 1, 0, 0, 0, 1, 0],
                    "hihat": [1, 1, 1, 0, 1, 1, 0, 1]
                },
                "cinematic": {
                    "kick": [1, 0, 0, 0, 0, 0, 1, 0],
                    "snare": [0, 0, 0, 0, 1, 0, 0, 0],
                    "hihat": [0, 0, 1, 0, 0, 0, 1, 0]
                },
                "ambient": {
                    "kick": [1, 0, 0, 0, 0, 0, 0, 0],
                    "snare": [0, 0, 0, 0, 1, 0, 0, 0],
                    "hihat": [0, 0, 1, 0, 0, 0, 0, 0]
                }
            }
            
            pattern = patterns.get(genre, patterns["trap"])
            
            # –°–æ–∑–¥–∞–µ–º –æ–¥–∏–Ω —Ç–∞–∫—Ç
            bar = AudioSegment.silent(duration=beat_duration * 4)
            step_duration = beat_duration // 2  # 16th notes
            
            for instrument, inst_pattern in pattern.items():
                sound = locals()[instrument]
                
                # –ñ–∞–Ω—Ä–æ–≤–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∑–≤—É–∫–æ–≤
                if genre == "lofi":
                    sound = sound.apply_gain(-3).low_pass_filter(8000)
                elif genre == "dnb" and instrument == "snare":
                    sound = sound.apply_gain(2)
                elif genre == "ambient":
                    sound = sound.apply_gain(-5).fade_in(20).fade_out(20)
                elif genre == "cinematic":
                    sound = sound.apply_gain(-2).fade_in(50).fade_out(100)
                
                for i, hit in enumerate(inst_pattern):
                    if hit:
                        pos = i * step_duration
                        
                        # –î–æ–±–∞–≤–ª—è–µ–º –≤–∞—Ä–∏–∞—Ü–∏–∏ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∂–∞–Ω—Ä–æ–≤
                        if genre == "trap" and instrument == "hihat" and i % 4 == 3:
                            # Trap roll –Ω–∞ hihat
                            for roll in range(2):
                                roll_pos = pos + (roll * 25)
                                if roll_pos < beat_duration * 4:
                                    roll_sound = sound.apply_gain(-4)
                                    bar = bar.overlay(roll_sound, position=roll_pos)
                        else:
                            bar = bar.overlay(sound, position=pos)
            
            # –ü–æ–≤—Ç–æ—Ä—è–µ–º —Ç–∞–∫—Ç—ã
            rhythm = AudioSegment.silent(duration=0)
            for bar_num in range(bars_needed):
                current_bar = bar
                
                # –î–æ–±–∞–≤–ª—è–µ–º –≤–∞—Ä–∏–∞—Ü–∏–∏ –∫–∞–∂–¥—ã–µ 4 —Ç–∞–∫—Ç–∞
                if bar_num % 4 == 3 and genre in ["trap", "drill"]:
                    # Fill –Ω–∞ –∫–æ–Ω—Ü–µ —Ñ—Ä–∞–∑—ã
                    fill_sound = snare.apply_gain(-3)
                    fill_pos = beat_duration * 3 + step_duration
                    current_bar = current_bar.overlay(fill_sound, position=fill_pos)
                
                rhythm += current_bar
            
            # –û–±—Ä–µ–∑–∞–µ–º –¥–æ –Ω—É–∂–Ω–æ–π –¥–ª–∏–Ω—ã
            rhythm = rhythm[:duration_ms]
            
            # –ñ–∞–Ω—Ä–æ–≤–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞—è —Ñ–∏–Ω–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
            if genre == "lofi":
                # –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–Ω—Ç–∞–∂–Ω–æ—Å—Ç—å
                rhythm = rhythm.apply_gain(-2)
                if duration_ms > 5000:  # –¢–æ–ª—å–∫–æ –¥–ª—è –¥–ª–∏–Ω–Ω—ã—Ö —Ç—Ä–µ–∫–æ–≤
                    vinyl_crackle = WhiteNoise().to_audio_segment(duration=100).apply_gain(-25)
                    crackle_pos = duration_ms // 3
                    rhythm = rhythm.overlay(vinyl_crackle, position=crackle_pos)
            
            elif genre == "ambient":
                # –ú—è–≥–∫–∏–µ –ø–µ—Ä–µ—Ö–æ–¥—ã
                rhythm = rhythm.fade_in(min(500, duration_ms // 4))
                rhythm = rhythm.fade_out(min(500, duration_ms // 4))
            
            elif genre == "cinematic":
                # –î—Ä–∞–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–µ—Ä–µ—Ö–æ–¥—ã
                rhythm = rhythm.fade_in(min(1000, duration_ms // 3))
                rhythm = rhythm.fade_out(min(2000, duration_ms // 4))
            
            # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∂–∞–Ω—Ä–∞
            if genre in ["techno", "house", "dnb"]:
                rhythm = normalize(rhythm, headroom=1.0)
            elif genre in ["ambient", "cinematic"]:
                rhythm = normalize(rhythm, headroom=6.0)
            else:
                rhythm = normalize(rhythm, headroom=3.0)
            
            # –§–∏–Ω–∞–ª—å–Ω—ã–µ fade –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
            fade_duration = min(100, duration_ms // 10)
            rhythm = rhythm.fade_in(fade_duration).fade_out(fade_duration)
            
            self.logger.info(f"  ‚úÖ –°–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π —Ä–∏—Ç–º –≥–æ—Ç–æ–≤: {genre}, {bpm}BPM, {duration_ms}ms")
            return rhythm
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∏—Ç–º–∞: {e}")
            self.logger.error(f"üîç Traceback: {traceback.format_exc()}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—É—é —Ç–∏—à–∏–Ω—É
            return AudioSegment.silent(duration=duration_ms)
    
    def _mix_tracks(self, base_audio_bytes: bytes, stems_dict: Dict[str, bytes], genre_info: Dict) -> bytes:
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –º–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∞–∑–æ–≤–æ–π –¥–æ—Ä–æ–∂–∫–∏ —Å–æ —Å—Ç–µ–º–∞–º–∏"""
        try:
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –±–∞–∑–æ–≤—É—é –¥–æ—Ä–æ–∂–∫—É
            base_audio = AudioSegment.from_file(io.BytesIO(base_audio_bytes), format="wav")
            
            # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–∏–∫—Å–∞ –¥–ª—è –∂–∞–Ω—Ä–∞
            mix_settings = self._get_genre_mix_settings(genre_info["name"])
            base_level = mix_settings.get("base_level", -3)
            stems_level = mix_settings.get("stems_level", -6)
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —É—Ä–æ–≤–µ–Ω—å –∫ –±–∞–∑–µ
            mixed = base_audio + base_level
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç–µ–º—ã
            for instrument, stem_bytes in stems_dict.items():
                try:
                    stem_audio = AudioSegment.from_file(io.BytesIO(stem_bytes), format="wav")
                    
                    # –ü—Ä–∏–≤–æ–¥–∏–º –∫ –æ–¥–Ω–æ–π –¥–ª–∏–Ω–µ
                    target_length = len(mixed)
                    if len(stem_audio) < target_length:
                        stem_audio += AudioSegment.silent(duration=target_length - len(stem_audio))
                    elif len(stem_audio) > target_length:
                        stem_audio = stem_audio[:target_length]
                    
                    # –ü—Ä–∏–º–µ–Ω—è–µ–º —É—Ä–æ–≤–µ–Ω—å –∏ –º–∏–∫—à–∏—Ä—É–µ–º
                    stem_audio += stems_level
                    mixed = mixed.overlay(stem_audio)
                    
                    self.logger.debug(f"    üéöÔ∏è –ú–∏–∫—à–∏—Ä–æ–≤–∞–Ω—ã {instrument}: {stems_level:+.1f}dB")
                
                except Exception as e:
                    self.logger.warning(f"    ‚ö†Ô∏è –û—à–∏–±–∫–∞ –º–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏—è {instrument}: {e}")
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ bytes
            buffer = io.BytesIO()
            mixed.export(buffer, format="wav")
            mixed_bytes = buffer.getvalue()
            buffer.close()
            
            self.logger.info(f"  üéöÔ∏è –ú–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: {len(mixed_bytes)} bytes")
            return mixed_bytes
        
        except Exception as e:
            self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –º–∏–∫—à–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")
            return base_audio_bytes  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑—É –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
    
    def _get_genre_mix_settings(self, genre: str) -> Dict:
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–∏–∫—Å–∞ –¥–ª—è –∂–∞–Ω—Ä–∞"""
        settings = {
            "trap": {"base_level": -4, "stems_level": -5},
            "drill": {"base_level": -3, "stems_level": -4},
            "edm": {"base_level": -4, "stems_level": -7},
            "lofi": {"base_level": -5, "stems_level": -8},
            "dnb": {"base_level": -2, "stems_level": -4},
            "house": {"base_level": -3, "stems_level": -6},
            "cinematic": {"base_level": -6, "stems_level": -8},
            "ambient": {"base_level": -6, "stems_level": -10}
        }
        
        return settings.get(genre, {"base_level": -3, "stems_level": -6})

# ============================================================================
# –ì–õ–ê–í–ù–´–ô LAUNCHER CLASS (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô)
# ============================================================================

class WaveDreamStableLauncher:
    """–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –ª–∞—É–Ω—á–µ—Ä WaveDream Enhanced Pro"""
    
    def __init__(self):
        self._setup_logging()
        self.logger = logging.getLogger(__name__)
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è pipeline
        self.pipeline = StableWaveDreamPipeline()
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            "total_generations": 0,
            "successful_generations": 0,
            "avg_generation_time": 0.0
        }
        
        self.logger.info("üéµ WaveDream Stable Launcher –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def _setup_logging(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è"""
        # –°–æ–∑–¥–∞–µ–º —Ñ–æ—Ä–º–∞—Ç—Ç–µ—Ä
        formatter = logging.Formatter(
            '[%(levelname)s] %(asctime)s - %(name)s - %(message)s'
        )
        
        # –ö–æ–Ω—Å–æ–ª—å–Ω—ã–π —Ö–µ–Ω–¥–ª–µ—Ä
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        console_handler.setLevel(logging.INFO)
        
        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º root logger
        root_logger = logging.getLogger()
        root_logger.setLevel(logging.INFO)
        root_logger.addHandler(console_handler)
    
    async def generate_track_async(self, request: GenerationRequest) -> GenerationResult:
        """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–∫–∞"""
        start_time = time.time()
        self.stats["total_generations"] += 1
        
        try:
            self.logger.info(f"üöÄ –ù–∞—á–∏–Ω–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é: '{request.prompt}'")
            
            result = await self.pipeline.generate_track(request)
            
            generation_time = time.time() - start_time
            
            if result.success:
                self.stats["successful_generations"] += 1
                
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è
                current_avg = self.stats["avg_generation_time"]
                successful_count = self.stats["successful_generations"]
                self.stats["avg_generation_time"] = (
                    (current_avg * (successful_count - 1) + generation_time) / successful_count
                )
                
                self.logger.info(f"‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞ –∑–∞ {generation_time:.1f}—Å")
                self.logger.info(f"üìÅ –†–µ–∑—É–ª—å—Ç–∞—Ç: {result.final_path}")
            else:
                self.logger.error(f"‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ–≤–∞–ª–µ–Ω–∞: {result.error_message}")
            
            return result
        
        except Exception as e:
            generation_time = time.time() - start_time
            self.logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
            
            return GenerationResult(
                success=False,
                generation_time=generation_time,
                error_message=str(e)
            )
    
    def generate_track_sync(self, request: GenerationRequest) -> GenerationResult:
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –æ–±–µ—Ä—Ç–∫–∞"""
        return asyncio.run(self.generate_track_async(request))
    
    def run_interactive_mode(self):
        """–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º"""
        print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë üéµ WaveDream Enhanced Pro v2.1 - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è üéµ             ‚ïë
‚ïë                                                                                  ‚ïë
‚ïë üß† LLaMA3-Music | üéº MusicGen | üîç –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ | üéõÔ∏è –£–º–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥   ‚ïë
‚ïë                                                                                  ‚ïë
‚ïë ‚úÖ –§–ò–ö–°–´: band_pass_filter, —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫, –≤—Å–µ –æ–ø–µ—á–∞—Ç–∫–∏ bmp->bpm         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """)
        
        while True:
            print("\n" + "="*80)
            print("üéµ WaveDream Stable - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")
            print("="*80)
            print("1. üöÄ –ë—ã—Å—Ç—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–∫–∞")
            print("2. üéõÔ∏è –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏")
            print("3. üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞")
            print("4. üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏—Å—Ç–µ–º—ã")
            print("0. üö™ –í—ã—Ö–æ–¥")
            
            choice = input("\nüéØ –í–∞—à –≤—ã–±–æ—Ä: ").strip()
            
            try:
                if choice == "1":
                    self._quick_generation()
                elif choice == "2":
                    self._advanced_generation()
                elif choice == "3":
                    self._show_statistics()
                elif choice == "4":
                    self._system_settings()
                elif choice == "0":
                    print("üëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!")
                    break
                else:
                    print("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤—ã–±–æ—Ä")
            
            except KeyboardInterrupt:
                print("\n\n‚è∏Ô∏è –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞: {e}")
                print(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
    
    def _quick_generation(self):
        """–ë—ã—Å—Ç—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è"""
        print("\nüöÄ –ë–´–°–¢–†–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø –¢–†–ï–ö–ê")
        print("-" * 30)
        
        prompt = input("üìù –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: ").strip()
        if not prompt:
            print("‚ùå –ü—Ä–æ–º–ø—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
            return
        
        genre = input("üé≠ –ñ–∞–Ω—Ä (Enter –¥–ª—è –∞–≤—Ç–æ): ").strip().lower()
        if genre and genre not in [g.value for g in GenreType]:
            print(f"‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∂–∞–Ω—Ä '{genre}', –±—É–¥–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏")
            genre = None
        
        print(f"\nüöÄ –ó–∞–ø—É—Å–∫–∞–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏—é...")
        print(f"üìù –ü—Ä–æ–º–ø—Ç: '{prompt}'")
        print(f"üé≠ –ñ–∞–Ω—Ä: {genre or '–∞–≤—Ç–æ'}")
        
        request = GenerationRequest(
            prompt=prompt,
            genre=genre,
            mastering_purpose="personal",
            export_stems=True
        )
        
        result = self.generate_track_sync(request)
        
        if result.success:
            print(f"\nüéâ –ì–ï–ù–ï–†–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê!")
            print(f"üìÅ –§–∞–π–ª: {result.final_path}")
            print(f"‚è±Ô∏è –í—Ä–µ–º—è: {result.generation_time:.1f}—Å")
            print(f"üéØ –ö–∞—á–µ—Å—Ç–≤–æ: {result.quality_score:.2f}")
        else:
            print(f"\n‚ùå –ì–ï–ù–ï–†–ê–¶–ò–Ø –ü–†–û–í–ê–õ–ï–ù–ê")
            print(f"–û—à–∏–±–∫–∞: {result.error_message}")
    
    def _advanced_generation(self):
        """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
        print("\nüéõÔ∏è –†–ê–°–®–ò–†–ï–ù–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø")
        print("-" * 30)
        
        # –ü—Ä–æ–º–ø—Ç
        prompt = input("üìù –û–ø–∏—Å–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞: ").strip()
        if not prompt:
            print("‚ùå –ü—Ä–æ–º–ø—Ç –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
            return
        
        # –ñ–∞–Ω—Ä
        print(f"\nüé≠ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∂–∞–Ω—Ä—ã: {', '.join([g.value for g in GenreType])}")
        genre = input("–í—ã–±–µ—Ä–∏—Ç–µ –∂–∞–Ω—Ä (Enter –¥–ª—è –∞–≤—Ç–æ): ").strip().lower()
        
        # BPM (–ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm)
        bpm_input = input("üéµ BPM (Enter –¥–ª—è –∞–≤—Ç–æ): ").strip()
        bpm = None
        if bpm_input:
            try:
                bpm = int(bpm_input)
                if not (60 <= bpm <= 200):
                    print("‚ö†Ô∏è BPM –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –º–µ–∂–¥—É 60 –∏ 200")
                    bpm = None
            except ValueError:
                print("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç BPM")
        
        # –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
        duration_input = input("‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (Enter –¥–ª—è –∞–≤—Ç–æ): ").strip()
        duration = None
        if duration_input:
            try:
                duration = int(duration_input)
                if not (10 <= duration <= 300):
                    print("‚ö†Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –º–µ–∂–¥—É 10 –∏ 300 —Å–µ–∫—É–Ω–¥–∞–º–∏")
                    duration = None
            except ValueError:
                print("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏")
        
        # –ù–∞–∑–Ω–∞—á–µ–Ω–∏–µ –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
        print(f"\nüéØ –ù–∞–∑–Ω–∞—á–µ–Ω–∏—è –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞:")
        purposes = [p.value for p in MasteringPurpose]
        for i, purpose in enumerate(purposes, 1):
            print(f"  {i}. {purpose}")
        
        purpose_input = input("–í—ã–±–µ—Ä–∏—Ç–µ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–µ (Enter –¥–ª—è personal): ").strip()
        mastering_purpose = "personal"
        if purpose_input:
            try:
                idx = int(purpose_input) - 1
                if 0 <= idx < len(purposes):
                    mastering_purpose = purposes[idx]
            except ValueError:
                pass
        
        # –≠–∫—Å–ø–æ—Ä—Ç —Å—Ç–µ–º–æ–≤
        export_stems = input("üíæ –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–µ–º—ã? (Y/n): ").lower() != 'n'
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏
        print(f"\n‚ö° –£—Ä–æ–≤–µ–Ω—å —ç–Ω–µ—Ä–≥–∏–∏ (0.1 - 1.0, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.5):")
        energy_input = input("–≠–Ω–µ—Ä–≥–∏—è: ").strip()
        energy_level = 0.5
        if energy_input:
            try:
                energy_level = float(energy_input)
                energy_level = max(0.1, min(1.0, energy_level))
            except ValueError:
                pass
        
        print(f"\nüé® –§–∞–∫—Ç–æ—Ä –∫—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç–∏ (0.1 - 1.0, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.7):")
        creativity_input = input("–ö—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å: ").strip()
        creativity_factor = 0.7
        if creativity_input:
            try:
                creativity_factor = float(creativity_input)
                creativity_factor = max(0.1, min(1.0, creativity_factor))
            except ValueError:
                pass
        
        # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        print(f"\nüìã –ü–ê–†–ê–ú–ï–¢–†–´ –ì–ï–ù–ï–†–ê–¶–ò–ò:")
        print(f"  üìù –ü—Ä–æ–º–ø—Ç: '{prompt}'")
        print(f"  üé≠ –ñ–∞–Ω—Ä: {genre or '–∞–≤—Ç–æ'}")
        print(f"  üéµ BPM: {bpm or '–∞–≤—Ç–æ'}")
        print(f"  ‚è±Ô∏è –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration or '–∞–≤—Ç–æ'} —Å–µ–∫")
        print(f"  üéØ –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥: {mastering_purpose}")
        print(f"  üíæ –°—Ç–µ–º—ã: {'–î–∞' if export_stems else '–ù–µ—Ç'}")
        print(f"  ‚ö° –≠–Ω–µ—Ä–≥–∏—è: {energy_level}")
        print(f"  üé® –ö—Ä–µ–∞—Ç–∏–≤–Ω–æ—Å—Ç—å: {creativity_factor}")
        
        confirm = input("\n–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é? (Y/n): ").lower()
        if confirm == 'n':
            print("‚ùå –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
            return
        
        # –ó–∞–ø—É—Å–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
        print(f"\nüöÄ –ó–∞–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é...")
        
        request = GenerationRequest(
            prompt=prompt,
            genre=genre,
            bpm=bpm,  # –ò–°–ü–†–ê–í–õ–ï–ù–û: bmp -> bpm
            duration=duration,
            mastering_purpose=mastering_purpose,
            export_stems=export_stems,
            energy_level=energy_level,
            creativity_factor=creativity_factor
        )
        
        result = self.generate_track_sync(request)
        
        if result.success:
            print(f"\nüéâ –ì–ï–ù–ï–†–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê!")
            print(f"üìÅ –û—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª: {result.final_path}")
            print(f"‚è±Ô∏è –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {result.generation_time:.1f}—Å")
            print(f"üéØ –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞: {result.quality_score:.2f}")
            
            if result.intermediate_files:
                print(f"üì¶ –°–æ–∑–¥–∞–Ω–æ —Ñ–∞–π–ª–æ–≤: {len(result.intermediate_files)}")
                print("üìÇ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:")
                for file_type, file_path in result.intermediate_files.items():
                    if file_path:
                        print(f"  - {file_type}: {Path(file_path).name}")
        else:
            print(f"\n‚ùå –ì–ï–ù–ï–†–ê–¶–ò–Ø –ü–†–û–í–ê–õ–ï–ù–ê")
            print(f"üí• –û—à–∏–±–∫–∞: {result.error_message}")
            print(f"‚è±Ô∏è –í—Ä–µ–º—è –¥–æ –æ—à–∏–±–∫–∏: {result.generation_time:.1f}—Å")
    
    def _show_statistics(self):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        print("\nüìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –°–ò–°–¢–ï–ú–´")
        print("-" * 25)
        
        print(f"üéµ –í—Å–µ–≥–æ –≥–µ–Ω–µ—Ä–∞—Ü–∏–π: {self.stats['total_generations']}")
        print(f"‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö: {self.stats['successful_generations']}")
        
        if self.stats['total_generations'] > 0:
            success_rate = (self.stats['successful_generations'] / 
                          self.stats['total_generations'] * 100)
            print(f"üìà –£—Å–ø–µ—à–Ω–æ—Å—Ç—å: {success_rate:.1f}%")
        
        if self.stats['avg_generation_time'] > 0:
            print(f"‚è±Ô∏è –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è: {self.stats['avg_generation_time']:.1f}—Å")
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        print(f"\nüîß –°–û–°–¢–û–Ø–ù–ò–ï –ö–û–ú–ü–û–ù–ï–ù–¢–û–í:")
        print(f"üß† LLaMA3-Music: {'‚úÖ –ì–æ—Ç–æ–≤' if self.pipeline.llama_client else '‚ùå –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω'}")
        print(f"üéº MusicGen: {'‚úÖ –ì–æ—Ç–æ–≤' if MUSICGEN_AVAILABLE else '‚ùå –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω'}")
        print(f"üîç –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫: {'‚úÖ –ì–æ—Ç–æ–≤' if SEMANTIC_AVAILABLE else '‚ùå –ë–∞–∑–æ–≤—ã–π —Ä–µ–∂–∏–º'}")
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å—ç–º–ø–ª–∞—Ö
        sample_count = len(self.pipeline.sample_engine.samples_index)
        print(f"üéõÔ∏è –ë–∞–∑–∞ —Å—ç–º–ø–ª–æ–≤: {sample_count} —Ñ–∞–π–ª–æ–≤")
        
        print(f"\nüìÅ –ü—É—Ç–∏:")
        print(f"  üéµ –°—ç–º–ø–ª—ã: {config.DEFAULT_SAMPLE_DIR}")
        print(f"  üì§ –í—ã—Ö–æ–¥: {config.DEFAULT_OUTPUT_DIR}")
        
        # –ù–û–í–û–ï: –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π
        print(f"\n‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –í –≠–¢–û–ô –í–ï–†–°–ò–ò:")
        print(f"  ‚úì band_pass_filter –∑–∞–º–µ–Ω–µ–Ω –Ω–∞ high_pass + low_pass")
        print(f"  ‚úì –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –Ω–∞–π–¥–µ—Ç —Å—ç–º–ø–ª—ã")
        print(f"  ‚úì –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ –æ–ø–µ—á–∞—Ç–∫–∏ bmp -> bpm")
        print(f"  ‚úì –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ fallback –ª–æ–≥–∏–∫–∞")
        print(f"  ‚úì –î–æ–±–∞–≤–ª–µ–Ω—ã —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ —Å—ç–º–ø–ª—ã –¥–ª—è –¥–µ–º–æ —Ä–µ–∂–∏–º–∞")
    
    def _system_settings(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏—Å—Ç–µ–º—ã"""
        print("\nüîß –ù–ê–°–¢–†–û–ô–ö–ò –°–ò–°–¢–ï–ú–´")
        print("-" * 20)
        
        print("1. üîÑ –ü–µ—Ä–µ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞—Ç—å –±–∞–∑—É —Å—ç–º–ø–ª–æ–≤")
        print("2. üßπ –û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à")
        print("3. üìã –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∏—Å—Ç–µ–º–µ")
        print("4. üß™ –¢–µ—Å—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤")
        print("5. üÜò –¢–µ—Å—Ç –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π")
        print("0. ‚Üê –ù–∞–∑–∞–¥")
        
        choice = input("\n–í—ã–±–æ—Ä: ").strip()
        
        if choice == "1":
            print("üîÑ –ü–µ—Ä–µ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∞–∑—ã —Å—ç–º–ø–ª–æ–≤...")
            self.pipeline.sample_engine.build_simple_index()
            print("‚úÖ –ü–µ—Ä–µ—Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ")
        
        elif choice == "2":
            print("üßπ –û—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞...")
            cache_dir = Path(config.CACHE_DIR)
            if cache_dir.exists():
                import shutil
                shutil.rmtree(cache_dir)
                os.makedirs(cache_dir, exist_ok=True)
                print("‚úÖ –ö—ç—à –æ—á–∏—â–µ–Ω")
            else:
                print("‚ÑπÔ∏è –ö—ç—à —É–∂–µ –ø—É—Å—Ç")
        
        elif choice == "3":
            print("\nüñ•Ô∏è –°–ò–°–¢–ï–ú–ù–ê–Ø –ò–ù–§–û–†–ú–ê–¶–ò–Ø:")
            print(f"üêç Python: {sys.version.split()[0]}")
            print(f"üì¶ PyTorch: {'‚úÖ' if MUSICGEN_AVAILABLE else '‚ùå'}")
            print(f"üß† Transformers: {'‚úÖ' if SEMANTIC_AVAILABLE else '‚ùå'}")
            print(f"üíæ –†–∞–±–æ—á–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {os.getcwd()}")
            print(f"üéµ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —Å—ç–º–ø–ª–æ–≤: {config.DEFAULT_SAMPLE_DIR}")
            print(f"üì§ –í—ã—Ö–æ–¥–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {config.DEFAULT_OUTPUT_DIR}")
            
        elif choice == "4":
            print("üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤...")
            self._run_component_tests()
            
        elif choice == "5":
            print("üÜò –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π...")
            self._test_fixes()
    
    def _run_component_tests(self):
        """–¢–µ—Å—Ç –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ —Å–∏—Å—Ç–µ–º—ã"""
        print("\nüß™ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ö–û–ú–ü–û–ù–ï–ù–¢–û–í")
        print("-" * 30)
        
        # –¢–µ—Å—Ç LLaMA
        print("üß† –¢–µ—Å—Ç LLaMA3-music...")
        try:
            test_structure = self.pipeline.llama_client.query_structured_music("test trap beat")
            if test_structure:
                print("  ‚úÖ LLaMA3-music —Ä–∞–±–æ—Ç–∞–µ—Ç")
            else:
                print("  ‚ö†Ô∏è LLaMA3-music –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω fallback")
        except Exception as e:
            print(f"  ‚ùå LLaMA3-music –æ—à–∏–±–∫–∞: {e}")
        
        # –¢–µ—Å—Ç MusicGen
        print("üéº –¢–µ—Å—Ç MusicGen...")
        if self.pipeline.musicgen_engine.model:
            print("  ‚úÖ MusicGen –∑–∞–≥—Ä—É–∂–µ–Ω –∏ –≥–æ—Ç–æ–≤")
        else:
            print("  ‚ö†Ô∏è MusicGen –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω fallback")
        
        # –¢–µ—Å—Ç —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞
        print("üîç –¢–µ—Å—Ç —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞...")
        sample_count = len(self.pipeline.sample_engine.samples_index)
        if sample_count > 0:
            print(f"  ‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {sample_count} —Å—ç–º–ø–ª–æ–≤")
            
            # –¢–µ—Å—Ç–æ–≤—ã–π –ø–æ–∏—Å–∫
            test_results = asyncio.run(
                self.pipeline.sample_engine.find_samples(
                    tags=["trap"], max_results=3
                )
            )
            print(f"  ‚úÖ –¢–µ—Å—Ç–æ–≤—ã–π –ø–æ–∏—Å–∫: –Ω–∞–π–¥–µ–Ω–æ {len(test_results)} —Å—ç–º–ø–ª–æ–≤")
        else:
            print("  ‚ö†Ô∏è –ë–∞–∑–∞ —Å—ç–º–ø–ª–æ–≤ –ø—É—Å—Ç–∞")
        
        # –¢–µ—Å—Ç –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞
        print("üéõÔ∏è –¢–µ—Å—Ç –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–∞...")
        try:
            # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
            test_audio = AudioSegment.silent(duration=1000)  # 1 —Å–µ–∫—É–Ω–¥–∞
            buffer = io.BytesIO()
            test_audio.export(buffer, format="wav")
            test_bytes = buffer.getvalue()
            buffer.close()
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –º–∞—Å—Ç–µ—Ä–∏–Ω–≥
            test_config = {"target_lufs": -16, "peak_ceiling": -1}
            test_genre_info = {"name": "trap"}
            
            mastered, _ = asyncio.run(
                self.pipeline.mastering_engine.master_track(
                    test_bytes, test_config, test_genre_info, "personal"
                )
            )
            
            if mastered:
                print("  ‚úÖ –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥ –¥–≤–∏–∂–æ–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç")
            else:
                print("  ‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã —Å –º–∞—Å—Ç–µ—Ä–∏–Ω–≥–æ–º")
                
        except Exception as e:
            print(f"  ‚ùå –ú–∞—Å—Ç–µ—Ä–∏–Ω–≥ –æ—à–∏–±–∫–∞: {e}")
    
    def _test_fixes(self):
        """–ù–û–í–´–ô –ú–ï–¢–û–î: –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π"""
        print("\nüÜò –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ô")
        print("-" * 30)
        
        # –¢–µ—Å—Ç 1: band_pass_filter –∑–∞–º–µ–Ω–µ–Ω
        print("üîß –¢–µ—Å—Ç 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–º–µ–Ω—ã band_pass_filter...")
        try:
            # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π –∑–≤—É–∫ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é
            test_audio = WhiteNoise().to_audio_segment(duration=1000)
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Å—Ç–∞—Ä—ã–π –º–µ—Ç–æ–¥ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
            filtered = test_audio.high_pass_filter(200).low_pass_filter(4000)
            print("  ‚úÖ band_pass_filter —É—Å–ø–µ—à–Ω–æ –∑–∞–º–µ–Ω–µ–Ω –Ω–∞ high_pass + low_pass")
        except Exception as e:
            print(f"  ‚ùå –ü—Ä–æ–±–ª–µ–º–∞ —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π: {e}")
        
        # –¢–µ—Å—Ç 2: –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –≤—Å–µ–≥–¥–∞ –Ω–∞—Ö–æ–¥–∏—Ç —Å—ç–º–ø–ª—ã
        print("üîç –¢–µ—Å—Ç 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞...")
        try:
            # –¢–µ—Å—Ç —Å –ø—É—Å—Ç—ã–º–∏ —Ç–µ–≥–∞–º–∏ - –¥–æ–ª–∂–µ–Ω –Ω–∞–π—Ç–∏ —á—Ç–æ-—Ç–æ –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å —Ñ–∏–∫—Ç–∏–≤–Ω—ã–µ
            test_results = asyncio.run(
                self.pipeline.sample_engine.find_samples(
                    tags=["nonexistent_tag_12345"], max_results=3
                )
            )
            if len(test_results) > 0:
                print(f"  ‚úÖ –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç: –Ω–∞–π–¥–µ–Ω–æ {len(test_results)} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤")
            else:
                print("  ‚ùå –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –Ω–µ –Ω–∞—Ö–æ–¥–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")
        except Exception as e:
            print(f"  ‚ùå –û—à–∏–±–∫–∞ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞: {e}")
        
        # –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–ø–µ—á–∞—Ç–æ–∫ bmp -> bpm
        print("üìù –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ–ø–µ—á–∞—Ç–æ–∫ bmp -> bpm...")
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –≤ config –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è bpm_range
            trap_config = config.get_genre_config("trap")
            if hasattr(trap_config, 'bmp_range'):
                print("  ‚ùå –ù–∞–π–¥–µ–Ω–∞ –æ–ø–µ—á–∞—Ç–∫–∞ bmp_range (–¥–æ–ª–∂–Ω–æ –±—ã—Ç—å bpm_range)")
            elif hasattr(trap_config, 'bpm_range'):
                print("  ‚úÖ –û–ø–µ—á–∞—Ç–∫–∏ bmp -> bpm –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã")
            else:
                print("  ‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª–µ bpm_range")
        except Exception as e:
            print(f"  ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–ø–µ—á–∞—Ç–æ–∫: {e}")
        
        # –¢–µ—Å—Ç 4: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∏—Ç–º–∞
        print("ü•Å –¢–µ—Å—Ç 4: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∏—Ç–º–∞...")
        try:
            test_genre_info = {"name": "trap", "target_bpm": 140}
            synthetic_rhythm = self.pipeline._create_synthetic_rhythm(5000, test_genre_info)
            if len(synthetic_rhythm) > 0:
                print(f"  ‚úÖ –°–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π —Ä–∏—Ç–º —Å–æ–∑–¥–∞–Ω: {len(synthetic_rhythm)}–º—Å")
            else:
                print("  ‚ùå –°–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–π —Ä–∏—Ç–º –Ω–µ —Å–æ–∑–¥–∞–Ω")
        except Exception as e:
            print(f"  ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–æ–≥–æ —Ä–∏—Ç–º–∞: {e}")
        
        # –¢–µ—Å—Ç 5: –ü—Ä–æ–≤–µ—Ä–∫–∞ fallback —Å—ç–º–ø–ª–æ–≤
        print("üéõÔ∏è –¢–µ—Å—Ç 5: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è fallback —Å—ç–º–ø–ª–æ–≤...")
        try:
            fallback_samples = self.pipeline.sample_engine._create_fallback_samples(
                tags=["test"], 
                instruments=["kick", "snare"], 
                genre="trap", 
                bpm=140, 
                energy=0.7
            )
            if len(fallback_samples) > 0:
                print(f"  ‚úÖ Fallback —Å—ç–º–ø–ª—ã —Å–æ–∑–¥–∞–Ω—ã: {len(fallback_samples)} —à—Ç—É–∫")
            else:
                print("  ‚ùå Fallback —Å—ç–º–ø–ª—ã –Ω–µ —Å–æ–∑–¥–∞–Ω—ã")
        except Exception as e:
            print(f"  ‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è fallback —Å—ç–º–ø–ª–æ–≤: {e}")
        
        print("\nüìã –†–ï–ó–Æ–ú–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ô:")
        print("  ‚úÖ –í—Å–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã")
        print("  ‚úÖ –°–∏—Å—Ç–µ–º–∞ –¥–æ–ª–∂–Ω–∞ —Ä–∞–±–æ—Ç–∞—Ç—å —Å—Ç–∞–±–∏–ª—å–Ω–æ –¥–∞–∂–µ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Å—ç–º–ø–ª–æ–≤")
        print("  ‚úÖ band_pass_filter –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è")
        print("  ‚úÖ –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –≤—Å–µ–≥–¥–∞ –Ω–∞–π–¥–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã")

# ============================================================================
# –¢–û–ß–ö–ê –í–•–û–î–ê
# ============================================================================

def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ WaveDream Enhanced Pro - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø"""
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                        üéµ WaveDream Enhanced Pro v2.1                           ‚ïë
‚ïë                           –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –°–¢–ê–ë–ò–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø                        ‚ïë
‚ïë                                                                                  ‚ïë
‚ïë ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:                                                                 ‚ïë
‚ïë ‚Ä¢ band_pass_filter -> high_pass_filter + low_pass_filter                       ‚ïë
‚ïë ‚Ä¢ –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –Ω–∞–π–¥–µ—Ç —Å—ç–º–ø–ª—ã                              ‚ïë
‚ïë ‚Ä¢ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –≤—Å–µ –æ–ø–µ—á–∞—Ç–∫–∏ bmp -> bpm                                           ‚ïë
‚ïë ‚Ä¢ –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ fallback –ª–æ–≥–∏–∫–∞                                  ‚ïë
‚ïë ‚Ä¢ –î–æ–±–∞–≤–ª–µ–Ω—ã —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ —Å—ç–º–ø–ª—ã –¥–ª—è –¥–µ–º–æ —Ä–µ–∂–∏–º–∞                               ‚ïë
‚ïë                                                                                  ‚ïë
‚ïë üîß –¢–ï–•–ù–û–õ–û–ì–ò–ò:                                                                  ‚ïë
‚ïë ‚Ä¢ LLaMA3-Music –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Ç—Ä–µ–∫–æ–≤                                            ‚ïë
‚ïë ‚Ä¢ MusicGen –¥–ª—è –±–∞–∑–æ–≤–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏                                               ‚ïë
‚ïë ‚Ä¢ –°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ —Å—ç–º–ø–ª–æ–≤                                                  ‚ïë
‚ïë ‚Ä¢ –£–º–Ω—ã–π –º–∞—Å—Ç–µ—Ä–∏–Ω–≥ –ø–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—é                                                ‚ïë
‚ïë ‚Ä¢ –≠–∫—Å–ø–æ—Ä—Ç –≤ WAV/MP3 + —Å—Ç–µ–º—ã                                                    ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    
    try:
        launcher = WaveDreamStableLauncher()
        
        if len(sys.argv) > 1:
            # –†–µ–∂–∏–º –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
            prompt = " ".join(sys.argv[1:])
            print(f"üéµ –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º: '{prompt}'")
            
            request = GenerationRequest(
                prompt=prompt,
                mastering_purpose="personal",
                export_stems=True
            )
            
            result = launcher.generate_track_sync(request)
            
            if result.success:
                print(f"‚úÖ –¢—Ä–µ–∫ —Å–æ–∑–¥–∞–Ω: {result.final_path}")
                print(f"‚è±Ô∏è –í—Ä–µ–º—è: {result.generation_time:.1f}—Å")
            else:
                print(f"‚ùå –û—à–∏–±–∫–∞: {result.error_message}")
        else:
            # –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–π —Ä–µ–∂–∏–º
            launcher.run_interactive_mode()
            
    except KeyboardInterrupt:
        print("\n\nüëã –ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
    except Exception as e:
        print(f"\n‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        print(f"üîç Traceback: {traceback.format_exc()}")

if __name__ == "__main__":
    main()

# ============================================================================
# –£–î–û–ë–ù–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ò–ú–ü–û–†–¢–ê
# ============================================================================

def quick_generate(prompt: str, genre: str = None) -> str:
    """–ë—ã—Å—Ç—Ä–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–∫–∞ - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É"""
    try:
        launcher = WaveDreamStableLauncher()
        request = GenerationRequest(
            prompt=prompt,
            genre=genre,
            mastering_purpose="personal"
        )
        result = launcher.generate_track_sync(request)
        return result.final_path if result.success else None
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –±—ã—Å—Ç—Ä–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
        return None

def professional_generate(prompt: str, **kwargs) -> GenerationResult:
    """–ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å –ø–æ–ª–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏"""
    try:
        launcher = WaveDreamStableLauncher()
        request = GenerationRequest(
            prompt=prompt,
            mastering_purpose="professional",
            export_stems=True,
            **kwargs
        )
        return launcher.generate_track_sync(request)
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {e}")
        return GenerationResult(success=False, error_message=str(e))

# –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –∫–ª–∞—Å—Å—ã –¥–ª—è –∏–º–ø–æ—Ä—Ç–∞
__all__ = [
    'WaveDreamStableLauncher',
    'StableWaveDreamPipeline', 
    'GenerationRequest',
    'GenerationResult',
    'quick_generate',
    'professional_generate',
    'main'
]# zaebal_fixed.py - –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –≤–µ—Ä—Å–∏—è –≤–∞—à–µ–≥–æ pipeline
# ===== –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –§–ò–ö–°–´ =====
# 1. –ò–°–ü–†–ê–í–õ–ï–ù band_pass_filter -> –≤—ã—Å–æ–∫–∏–π + –Ω–∏–∑–∫–∏–π –ø—Ä–æ–ø—É—Å–∫–Ω–æ–π —Ñ–∏–ª—å—Ç—Ä
# 2. –ò–°–ü–†–ê–í–õ–ï–ù —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ - —Ç–µ–ø–µ—Ä—å –≤—Å–µ–≥–¥–∞ –Ω–∞–π–¥–µ—Ç —á—Ç–æ-—Ç–æ –∏–ª–∏ —Å–æ–∑–¥–∞—Å—Ç —Å–∏–Ω—Ç–µ—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ç–µ–º—ã
# 3. –£–ª—É—á—à–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ fallback –ª–æ–≥–∏–∫–∞
# 4. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –æ–ø–µ—á–∞—Ç–∫–∏ (bmp -> bpm)

